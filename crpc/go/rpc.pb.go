// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rpc.proto

/*
Package crpc is a generated protocol buffer package.

It is generated from these files:
	rpc.proto

It has these top-level messages:
	EstimateRequest
	EstimationResponse
	CreateAddressRequest
	AccountAddressRequest
	PendingBalanceRequest
	PendingTransactionsRequest
	GenerateTransactionResponse
	SubcribeOnPaymentsRequest
	BlockchainPendingPayment
	Payment
	EmtpyResponse
	Balance
	Address
	Invoice
	CheckReachableRequest
	PendingTransactionsResponse
	GenerateTransactionRequest
	SendTransactionRequest
	InfoRequest
	LightningInfo
	InfoResponse
	CreateInvoiceRequest
	SendPaymentRequest
	CheckReachableResponse
*/
package crpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Asset is the list of a trading assets which are available in the exchange
// platform.
type Asset int32

const (
	Asset_BTC  Asset = 0
	Asset_BCH  Asset = 1
	Asset_ETH  Asset = 2
	Asset_LTC  Asset = 3
	Asset_DASH Asset = 4
)

var Asset_name = map[int32]string{
	0: "BTC",
	1: "BCH",
	2: "ETH",
	3: "LTC",
	4: "DASH",
}
var Asset_value = map[string]int32{
	"BTC":  0,
	"BCH":  1,
	"ETH":  2,
	"LTC":  3,
	"DASH": 4,
}

func (x Asset) String() string {
	return proto.EnumName(Asset_name, int32(x))
}
func (Asset) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Market is the list of trading markets which are available on the
// exchange platform.
type Market int32

const (
	Market_BTCETH  Market = 0
	Market_BTCBTH  Market = 1
	Market_BTCLTC  Market = 2
	Market_BTCDASH Market = 3
	Market_ETHLTC  Market = 4
)

var Market_name = map[int32]string{
	0: "BTCETH",
	1: "BTCBTH",
	2: "BTCLTC",
	3: "BTCDASH",
	4: "ETHLTC",
}
var Market_value = map[string]int32{
	"BTCETH":  0,
	"BTCBTH":  1,
	"BTCLTC":  2,
	"BTCDASH": 3,
	"ETHLTC":  4,
}

func (x Market) String() string {
	return proto.EnumName(Market_name, int32(x))
}
func (Market) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type Net int32

const (
	Net_Simnet  Net = 0
	Net_Testnet Net = 1
	Net_Mainnet Net = 2
)

var Net_name = map[int32]string{
	0: "Simnet",
	1: "Testnet",
	2: "Mainnet",
}
var Net_value = map[string]int32{
	"Simnet":  0,
	"Testnet": 1,
	"Mainnet": 2,
}

func (x Net) String() string {
	return proto.EnumName(Net_name, int32(x))
}
func (Net) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type EstimateRequest struct {
	Asset  string `protobuf:"bytes,1,opt,name=Asset,json=asset" json:"Asset,omitempty"`
	Amount string `protobuf:"bytes,2,opt,name=Amount,json=amount" json:"Amount,omitempty"`
}

func (m *EstimateRequest) Reset()                    { *m = EstimateRequest{} }
func (m *EstimateRequest) String() string            { return proto.CompactTextString(m) }
func (*EstimateRequest) ProtoMessage()               {}
func (*EstimateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EstimateRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *EstimateRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type EstimationResponse struct {
	Usd string `protobuf:"bytes,1,opt,name=usd" json:"usd,omitempty"`
}

func (m *EstimationResponse) Reset()                    { *m = EstimationResponse{} }
func (m *EstimationResponse) String() string            { return proto.CompactTextString(m) }
func (*EstimationResponse) ProtoMessage()               {}
func (*EstimationResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EstimationResponse) GetUsd() string {
	if m != nil {
		return m.Usd
	}
	return ""
}

type CreateAddressRequest struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Asset   string `protobuf:"bytes,2,opt,name=asset" json:"asset,omitempty"`
}

func (m *CreateAddressRequest) Reset()                    { *m = CreateAddressRequest{} }
func (m *CreateAddressRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateAddressRequest) ProtoMessage()               {}
func (*CreateAddressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CreateAddressRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *CreateAddressRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

type AccountAddressRequest struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Asset   string `protobuf:"bytes,2,opt,name=asset" json:"asset,omitempty"`
}

func (m *AccountAddressRequest) Reset()                    { *m = AccountAddressRequest{} }
func (m *AccountAddressRequest) String() string            { return proto.CompactTextString(m) }
func (*AccountAddressRequest) ProtoMessage()               {}
func (*AccountAddressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AccountAddressRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *AccountAddressRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

type PendingBalanceRequest struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Asset   string `protobuf:"bytes,2,opt,name=asset" json:"asset,omitempty"`
}

func (m *PendingBalanceRequest) Reset()                    { *m = PendingBalanceRequest{} }
func (m *PendingBalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*PendingBalanceRequest) ProtoMessage()               {}
func (*PendingBalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PendingBalanceRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *PendingBalanceRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

type PendingTransactionsRequest struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Asset   string `protobuf:"bytes,2,opt,name=asset" json:"asset,omitempty"`
}

func (m *PendingTransactionsRequest) Reset()                    { *m = PendingTransactionsRequest{} }
func (m *PendingTransactionsRequest) String() string            { return proto.CompactTextString(m) }
func (*PendingTransactionsRequest) ProtoMessage()               {}
func (*PendingTransactionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *PendingTransactionsRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *PendingTransactionsRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

type GenerateTransactionResponse struct {
	RawTx []byte `protobuf:"bytes,1,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	TxId  string `protobuf:"bytes,2,opt,name=tx_id,json=txId" json:"tx_id,omitempty"`
}

func (m *GenerateTransactionResponse) Reset()                    { *m = GenerateTransactionResponse{} }
func (m *GenerateTransactionResponse) String() string            { return proto.CompactTextString(m) }
func (*GenerateTransactionResponse) ProtoMessage()               {}
func (*GenerateTransactionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GenerateTransactionResponse) GetRawTx() []byte {
	if m != nil {
		return m.RawTx
	}
	return nil
}

func (m *GenerateTransactionResponse) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

type SubcribeOnPaymentsRequest struct {
	// Asset is the acronim name of asset.
	Asset string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	// Type is a type of network which is used to deliver the payment.
	Type string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
}

func (m *SubcribeOnPaymentsRequest) Reset()                    { *m = SubcribeOnPaymentsRequest{} }
func (m *SubcribeOnPaymentsRequest) String() string            { return proto.CompactTextString(m) }
func (*SubcribeOnPaymentsRequest) ProtoMessage()               {}
func (*SubcribeOnPaymentsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SubcribeOnPaymentsRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *SubcribeOnPaymentsRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// BlockchainPendingPayment is the transaction with confirmations number lower
// than required by the payment system to be treated as confirmed.
type BlockchainPendingPayment struct {
	Payment *Payment `protobuf:"bytes,1,opt,name=payment" json:"payment,omitempty"`
	// Confirmations is the number of confirmations.
	Confirmations int64 `protobuf:"varint,2,opt,name=confirmations" json:"confirmations,omitempty"`
	// ConfirmationsLeft is the number of confirmations left in order to
	// interpret the transaction as confirmed.
	ConfirmationsLeft int64 `protobuf:"varint,3,opt,name=confirmations_left,json=confirmationsLeft" json:"confirmations_left,omitempty"`
}

func (m *BlockchainPendingPayment) Reset()                    { *m = BlockchainPendingPayment{} }
func (m *BlockchainPendingPayment) String() string            { return proto.CompactTextString(m) }
func (*BlockchainPendingPayment) ProtoMessage()               {}
func (*BlockchainPendingPayment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *BlockchainPendingPayment) GetPayment() *Payment {
	if m != nil {
		return m.Payment
	}
	return nil
}

func (m *BlockchainPendingPayment) GetConfirmations() int64 {
	if m != nil {
		return m.Confirmations
	}
	return 0
}

func (m *BlockchainPendingPayment) GetConfirmationsLeft() int64 {
	if m != nil {
		return m.ConfirmationsLeft
	}
	return 0
}

// Payment is the structure which describe the action of funds movement from
// one user to another.
type Payment struct {
	// ID is an number which identifies the transaction inside the payment
	// system.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Amount is an number of money which is translated from one User to
	// another in this transaction.
	Amount string `protobuf:"bytes,2,opt,name=amount" json:"amount,omitempty"`
	// Account is the receiver account.
	Account string `protobuf:"bytes,3,opt,name=account" json:"account,omitempty"`
	// Address is an address of receiver.
	Address string `protobuf:"bytes,4,opt,name=address" json:"address,omitempty"`
	// Type is a type of network which is used to deliver the payment.
	Type string `protobuf:"bytes,5,opt,name=type" json:"type,omitempty"`
}

func (m *Payment) Reset()                    { *m = Payment{} }
func (m *Payment) String() string            { return proto.CompactTextString(m) }
func (*Payment) ProtoMessage()               {}
func (*Payment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Payment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Payment) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Payment) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *Payment) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Payment) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type EmtpyResponse struct {
}

func (m *EmtpyResponse) Reset()                    { *m = EmtpyResponse{} }
func (m *EmtpyResponse) String() string            { return proto.CompactTextString(m) }
func (*EmtpyResponse) ProtoMessage()               {}
func (*EmtpyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type Balance struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *Balance) Reset()                    { *m = Balance{} }
func (m *Balance) String() string            { return proto.CompactTextString(m) }
func (*Balance) ProtoMessage()               {}
func (*Balance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Balance) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type Address struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Address) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type Invoice struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *Invoice) Reset()                    { *m = Invoice{} }
func (m *Invoice) String() string            { return proto.CompactTextString(m) }
func (*Invoice) ProtoMessage()               {}
func (*Invoice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Invoice) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type CheckReachableRequest struct {
	Asset       string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	IdentityKey string `protobuf:"bytes,2,opt,name=identity_key,json=identityKey" json:"identity_key,omitempty"`
}

func (m *CheckReachableRequest) Reset()                    { *m = CheckReachableRequest{} }
func (m *CheckReachableRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckReachableRequest) ProtoMessage()               {}
func (*CheckReachableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *CheckReachableRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *CheckReachableRequest) GetIdentityKey() string {
	if m != nil {
		return m.IdentityKey
	}
	return ""
}

type PendingTransactionsResponse struct {
	Payments []*BlockchainPendingPayment `protobuf:"bytes,1,rep,name=payments" json:"payments,omitempty"`
}

func (m *PendingTransactionsResponse) Reset()                    { *m = PendingTransactionsResponse{} }
func (m *PendingTransactionsResponse) String() string            { return proto.CompactTextString(m) }
func (*PendingTransactionsResponse) ProtoMessage()               {}
func (*PendingTransactionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *PendingTransactionsResponse) GetPayments() []*BlockchainPendingPayment {
	if m != nil {
		return m.Payments
	}
	return nil
}

type GenerateTransactionRequest struct {
	Asset           string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	ReceiverAddress string `protobuf:"bytes,2,opt,name=receiver_address,json=receiverAddress" json:"receiver_address,omitempty"`
	Amount          string `protobuf:"bytes,3,opt,name=amount" json:"amount,omitempty"`
}

func (m *GenerateTransactionRequest) Reset()                    { *m = GenerateTransactionRequest{} }
func (m *GenerateTransactionRequest) String() string            { return proto.CompactTextString(m) }
func (*GenerateTransactionRequest) ProtoMessage()               {}
func (*GenerateTransactionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GenerateTransactionRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *GenerateTransactionRequest) GetReceiverAddress() string {
	if m != nil {
		return m.ReceiverAddress
	}
	return ""
}

func (m *GenerateTransactionRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type SendTransactionRequest struct {
	Asset string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	RawTx []byte `protobuf:"bytes,2,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
}

func (m *SendTransactionRequest) Reset()                    { *m = SendTransactionRequest{} }
func (m *SendTransactionRequest) String() string            { return proto.CompactTextString(m) }
func (*SendTransactionRequest) ProtoMessage()               {}
func (*SendTransactionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *SendTransactionRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *SendTransactionRequest) GetRawTx() []byte {
	if m != nil {
		return m.RawTx
	}
	return nil
}

type InfoRequest struct {
}

func (m *InfoRequest) Reset()                    { *m = InfoRequest{} }
func (m *InfoRequest) String() string            { return proto.CompactTextString(m) }
func (*InfoRequest) ProtoMessage()               {}
func (*InfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

type LightningInfo struct {
	Host string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	// Port is the port over which other peers could connect to the lightning
	// network daemon.
	Port string `protobuf:"bytes,2,opt,name=port" json:"port,omitempty"`
	// MinAmount is the minimal amount of funds which could be used for
	// payment via the lightning network daemon.
	MinAmount string `protobuf:"bytes,3,opt,name=min_amount,json=minAmount" json:"min_amount,omitempty"`
	// MaxAmount is the maximum amount of funds which could be used for
	// payment via lightning network deaemon.
	MaxAmount string `protobuf:"bytes,4,opt,name=max_amount,json=maxAmount" json:"max_amount,omitempty"`
	// IdentityPubKey of lightning network node.
	IdentityPubkey string `protobuf:"bytes,5,opt,name=identity_pubkey,json=identityPubkey" json:"identity_pubkey,omitempty"`
	// Alias is the string which represents the lightning network node in the
	// network, this data could be seen in peer-to-peer discovery messages.
	Alias string `protobuf:"bytes,6,opt,name=alias" json:"alias,omitempty"`
	// NumPendingChannels is the number of channels which are in the state of
	// awaitaning for blockchain confirmation.
	NumPendingChannels uint32 `protobuf:"varint,7,opt,name=num_pending_channels,json=numPendingChannels" json:"num_pending_channels,omitempty"`
	// NumPendingChannels is the number of channels which were confirmed and
	// could be used for payments.
	NumActiveChannels uint32 `protobuf:"varint,8,opt,name=num_active_channels,json=numActiveChannels" json:"num_active_channels,omitempty"`
	// Number of peers
	NumPeers uint32 `protobuf:"varint,9,opt,name=num_peers,json=numPeers" json:"num_peers,omitempty"`
	// The node's current view of the height of the best block
	BlockHeight uint32 `protobuf:"varint,10,opt,name=block_height,json=blockHeight" json:"block_height,omitempty"`
	// The node's current view of the hash of the best block
	BlockHash string `protobuf:"bytes,11,opt,name=block_hash,json=blockHash" json:"block_hash,omitempty"`
}

func (m *LightningInfo) Reset()                    { *m = LightningInfo{} }
func (m *LightningInfo) String() string            { return proto.CompactTextString(m) }
func (*LightningInfo) ProtoMessage()               {}
func (*LightningInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *LightningInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *LightningInfo) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *LightningInfo) GetMinAmount() string {
	if m != nil {
		return m.MinAmount
	}
	return ""
}

func (m *LightningInfo) GetMaxAmount() string {
	if m != nil {
		return m.MaxAmount
	}
	return ""
}

func (m *LightningInfo) GetIdentityPubkey() string {
	if m != nil {
		return m.IdentityPubkey
	}
	return ""
}

func (m *LightningInfo) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *LightningInfo) GetNumPendingChannels() uint32 {
	if m != nil {
		return m.NumPendingChannels
	}
	return 0
}

func (m *LightningInfo) GetNumActiveChannels() uint32 {
	if m != nil {
		return m.NumActiveChannels
	}
	return 0
}

func (m *LightningInfo) GetNumPeers() uint32 {
	if m != nil {
		return m.NumPeers
	}
	return 0
}

func (m *LightningInfo) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *LightningInfo) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

type InfoResponse struct {
	// Net represent currently configures blockchain network supported by
	// service.
	Net Net `protobuf:"varint,1,opt,name=net,enum=crpc.Net" json:"net,omitempty"`
	// Time is the current connector local time.
	Time         string         `protobuf:"bytes,2,opt,name=time" json:"time,omitempty"`
	LightingInfo *LightningInfo `protobuf:"bytes,3,opt,name=lighting_info,json=lightingInfo" json:"lighting_info,omitempty"`
}

func (m *InfoResponse) Reset()                    { *m = InfoResponse{} }
func (m *InfoResponse) String() string            { return proto.CompactTextString(m) }
func (*InfoResponse) ProtoMessage()               {}
func (*InfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

func (m *InfoResponse) GetNet() Net {
	if m != nil {
		return m.Net
	}
	return Net_Simnet
}

func (m *InfoResponse) GetTime() string {
	if m != nil {
		return m.Time
	}
	return ""
}

func (m *InfoResponse) GetLightingInfo() *LightningInfo {
	if m != nil {
		return m.LightingInfo
	}
	return nil
}

type CreateInvoiceRequest struct {
	Asset   string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	Account string `protobuf:"bytes,2,opt,name=account" json:"account,omitempty"`
	Amount  string `protobuf:"bytes,3,opt,name=amount" json:"amount,omitempty"`
}

func (m *CreateInvoiceRequest) Reset()                    { *m = CreateInvoiceRequest{} }
func (m *CreateInvoiceRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateInvoiceRequest) ProtoMessage()               {}
func (*CreateInvoiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *CreateInvoiceRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *CreateInvoiceRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *CreateInvoiceRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type SendPaymentRequest struct {
	Asset   string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	Invoice string `protobuf:"bytes,2,opt,name=invoice" json:"invoice,omitempty"`
}

func (m *SendPaymentRequest) Reset()                    { *m = SendPaymentRequest{} }
func (m *SendPaymentRequest) String() string            { return proto.CompactTextString(m) }
func (*SendPaymentRequest) ProtoMessage()               {}
func (*SendPaymentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *SendPaymentRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *SendPaymentRequest) GetInvoice() string {
	if m != nil {
		return m.Invoice
	}
	return ""
}

type CheckReachableResponse struct {
	IsReachable bool `protobuf:"varint,2,opt,name=isReachable" json:"isReachable,omitempty"`
}

func (m *CheckReachableResponse) Reset()                    { *m = CheckReachableResponse{} }
func (m *CheckReachableResponse) String() string            { return proto.CompactTextString(m) }
func (*CheckReachableResponse) ProtoMessage()               {}
func (*CheckReachableResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *CheckReachableResponse) GetIsReachable() bool {
	if m != nil {
		return m.IsReachable
	}
	return false
}

func init() {
	proto.RegisterType((*EstimateRequest)(nil), "crpc.EstimateRequest")
	proto.RegisterType((*EstimationResponse)(nil), "crpc.EstimationResponse")
	proto.RegisterType((*CreateAddressRequest)(nil), "crpc.CreateAddressRequest")
	proto.RegisterType((*AccountAddressRequest)(nil), "crpc.AccountAddressRequest")
	proto.RegisterType((*PendingBalanceRequest)(nil), "crpc.PendingBalanceRequest")
	proto.RegisterType((*PendingTransactionsRequest)(nil), "crpc.PendingTransactionsRequest")
	proto.RegisterType((*GenerateTransactionResponse)(nil), "crpc.GenerateTransactionResponse")
	proto.RegisterType((*SubcribeOnPaymentsRequest)(nil), "crpc.SubcribeOnPaymentsRequest")
	proto.RegisterType((*BlockchainPendingPayment)(nil), "crpc.BlockchainPendingPayment")
	proto.RegisterType((*Payment)(nil), "crpc.Payment")
	proto.RegisterType((*EmtpyResponse)(nil), "crpc.EmtpyResponse")
	proto.RegisterType((*Balance)(nil), "crpc.Balance")
	proto.RegisterType((*Address)(nil), "crpc.Address")
	proto.RegisterType((*Invoice)(nil), "crpc.Invoice")
	proto.RegisterType((*CheckReachableRequest)(nil), "crpc.CheckReachableRequest")
	proto.RegisterType((*PendingTransactionsResponse)(nil), "crpc.PendingTransactionsResponse")
	proto.RegisterType((*GenerateTransactionRequest)(nil), "crpc.GenerateTransactionRequest")
	proto.RegisterType((*SendTransactionRequest)(nil), "crpc.SendTransactionRequest")
	proto.RegisterType((*InfoRequest)(nil), "crpc.InfoRequest")
	proto.RegisterType((*LightningInfo)(nil), "crpc.LightningInfo")
	proto.RegisterType((*InfoResponse)(nil), "crpc.InfoResponse")
	proto.RegisterType((*CreateInvoiceRequest)(nil), "crpc.CreateInvoiceRequest")
	proto.RegisterType((*SendPaymentRequest)(nil), "crpc.SendPaymentRequest")
	proto.RegisterType((*CheckReachableResponse)(nil), "crpc.CheckReachableResponse")
	proto.RegisterEnum("crpc.Asset", Asset_name, Asset_value)
	proto.RegisterEnum("crpc.Market", Market_name, Market_value)
	proto.RegisterEnum("crpc.Net", Net_name, Net_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Connector service

type ConnectorClient interface {
	//
	// CreateAddress is used to create deposit address in choosen blockchain
	// network.
	//
	// NOTE: Works only for blockchain daemons.
	CreateAddress(ctx context.Context, in *CreateAddressRequest, opts ...grpc.CallOption) (*Address, error)
	//
	// AccountAddress return the deposit address of account.
	//
	// NOTE: Works only for blockchain daemons.
	AccountAddress(ctx context.Context, in *AccountAddressRequest, opts ...grpc.CallOption) (*Address, error)
	//
	// PendingBalance return the amount of funds waiting to be confirmed.
	//
	// NOTE: Works only for blockchain daemons.
	PendingBalance(ctx context.Context, in *PendingBalanceRequest, opts ...grpc.CallOption) (*Balance, error)
	//
	// PendingTransactions return the transactions which has confirmation
	// number lower the required by payment system.
	//
	// NOTE: Works only for blockchain daemons.
	PendingTransactions(ctx context.Context, in *PendingTransactionsRequest, opts ...grpc.CallOption) (*PendingTransactionsResponse, error)
	//
	// GenerateTransaction generates raw blockchain transaction.
	//
	// NOTE: Blockchain endpoint.
	GenerateTransaction(ctx context.Context, in *GenerateTransactionRequest, opts ...grpc.CallOption) (*GenerateTransactionResponse, error)
	//
	// SendTransaction send the given transaction to the blockchain network.
	//
	// NOTE: Works only for blockchain daemons.
	SendTransaction(ctx context.Context, in *SendTransactionRequest, opts ...grpc.CallOption) (*EmtpyResponse, error)
	//
	// Info returns the information about the connector, it configaration and
	// network information of daemon with which it is working.
	Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error)
	//
	// CreateInvoice creates recept for sender lightning node which contains
	// the information about receiver node and
	//
	// NOTE: Works only for lightning network daemons.
	CreateInvoice(ctx context.Context, in *CreateInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error)
	//
	// SendPayment is used to send specific amount of money inside lightning
	// network.
	//
	// NOTE: Works only for lightning network daemons.
	SendPayment(ctx context.Context, in *SendPaymentRequest, opts ...grpc.CallOption) (*EmtpyResponse, error)
	//
	// CheckReachable checks that given node can be reached from our
	// lightning node.
	//
	// NOTE: Works only for lightning network daemons.
	CheckReachable(ctx context.Context, in *CheckReachableRequest, opts ...grpc.CallOption) (*CheckReachableResponse, error)
	//
	// Estimate estimates the dollar price of the choosen asset.
	Estimate(ctx context.Context, in *EstimateRequest, opts ...grpc.CallOption) (*EstimationResponse, error)
}

type connectorClient struct {
	cc *grpc.ClientConn
}

func NewConnectorClient(cc *grpc.ClientConn) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) CreateAddress(ctx context.Context, in *CreateAddressRequest, opts ...grpc.CallOption) (*Address, error) {
	out := new(Address)
	err := grpc.Invoke(ctx, "/crpc.Connector/CreateAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) AccountAddress(ctx context.Context, in *AccountAddressRequest, opts ...grpc.CallOption) (*Address, error) {
	out := new(Address)
	err := grpc.Invoke(ctx, "/crpc.Connector/AccountAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) PendingBalance(ctx context.Context, in *PendingBalanceRequest, opts ...grpc.CallOption) (*Balance, error) {
	out := new(Balance)
	err := grpc.Invoke(ctx, "/crpc.Connector/PendingBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) PendingTransactions(ctx context.Context, in *PendingTransactionsRequest, opts ...grpc.CallOption) (*PendingTransactionsResponse, error) {
	out := new(PendingTransactionsResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/PendingTransactions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GenerateTransaction(ctx context.Context, in *GenerateTransactionRequest, opts ...grpc.CallOption) (*GenerateTransactionResponse, error) {
	out := new(GenerateTransactionResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/GenerateTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) SendTransaction(ctx context.Context, in *SendTransactionRequest, opts ...grpc.CallOption) (*EmtpyResponse, error) {
	out := new(EmtpyResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/SendTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Info(ctx context.Context, in *InfoRequest, opts ...grpc.CallOption) (*InfoResponse, error) {
	out := new(InfoResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/Info", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) CreateInvoice(ctx context.Context, in *CreateInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error) {
	out := new(Invoice)
	err := grpc.Invoke(ctx, "/crpc.Connector/CreateInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) SendPayment(ctx context.Context, in *SendPaymentRequest, opts ...grpc.CallOption) (*EmtpyResponse, error) {
	out := new(EmtpyResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/SendPayment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) CheckReachable(ctx context.Context, in *CheckReachableRequest, opts ...grpc.CallOption) (*CheckReachableResponse, error) {
	out := new(CheckReachableResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/CheckReachable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Estimate(ctx context.Context, in *EstimateRequest, opts ...grpc.CallOption) (*EstimationResponse, error) {
	out := new(EstimationResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/Estimate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Connector service

type ConnectorServer interface {
	//
	// CreateAddress is used to create deposit address in choosen blockchain
	// network.
	//
	// NOTE: Works only for blockchain daemons.
	CreateAddress(context.Context, *CreateAddressRequest) (*Address, error)
	//
	// AccountAddress return the deposit address of account.
	//
	// NOTE: Works only for blockchain daemons.
	AccountAddress(context.Context, *AccountAddressRequest) (*Address, error)
	//
	// PendingBalance return the amount of funds waiting to be confirmed.
	//
	// NOTE: Works only for blockchain daemons.
	PendingBalance(context.Context, *PendingBalanceRequest) (*Balance, error)
	//
	// PendingTransactions return the transactions which has confirmation
	// number lower the required by payment system.
	//
	// NOTE: Works only for blockchain daemons.
	PendingTransactions(context.Context, *PendingTransactionsRequest) (*PendingTransactionsResponse, error)
	//
	// GenerateTransaction generates raw blockchain transaction.
	//
	// NOTE: Blockchain endpoint.
	GenerateTransaction(context.Context, *GenerateTransactionRequest) (*GenerateTransactionResponse, error)
	//
	// SendTransaction send the given transaction to the blockchain network.
	//
	// NOTE: Works only for blockchain daemons.
	SendTransaction(context.Context, *SendTransactionRequest) (*EmtpyResponse, error)
	//
	// Info returns the information about the connector, it configaration and
	// network information of daemon with which it is working.
	Info(context.Context, *InfoRequest) (*InfoResponse, error)
	//
	// CreateInvoice creates recept for sender lightning node which contains
	// the information about receiver node and
	//
	// NOTE: Works only for lightning network daemons.
	CreateInvoice(context.Context, *CreateInvoiceRequest) (*Invoice, error)
	//
	// SendPayment is used to send specific amount of money inside lightning
	// network.
	//
	// NOTE: Works only for lightning network daemons.
	SendPayment(context.Context, *SendPaymentRequest) (*EmtpyResponse, error)
	//
	// CheckReachable checks that given node can be reached from our
	// lightning node.
	//
	// NOTE: Works only for lightning network daemons.
	CheckReachable(context.Context, *CheckReachableRequest) (*CheckReachableResponse, error)
	//
	// Estimate estimates the dollar price of the choosen asset.
	Estimate(context.Context, *EstimateRequest) (*EstimationResponse, error)
}

func RegisterConnectorServer(s *grpc.Server, srv ConnectorServer) {
	s.RegisterService(&_Connector_serviceDesc, srv)
}

func _Connector_CreateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).CreateAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/CreateAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).CreateAddress(ctx, req.(*CreateAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_AccountAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).AccountAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/AccountAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).AccountAddress(ctx, req.(*AccountAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_PendingBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PendingBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).PendingBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/PendingBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).PendingBalance(ctx, req.(*PendingBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_PendingTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PendingTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).PendingTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/PendingTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).PendingTransactions(ctx, req.(*PendingTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GenerateTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GenerateTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/GenerateTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GenerateTransaction(ctx, req.(*GenerateTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_SendTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).SendTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/SendTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).SendTransaction(ctx, req.(*SendTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Info_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(InfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Info(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/Info",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Info(ctx, req.(*InfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_CreateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).CreateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/CreateInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).CreateInvoice(ctx, req.(*CreateInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_SendPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).SendPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/SendPayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).SendPayment(ctx, req.(*SendPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_CheckReachable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckReachableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).CheckReachable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/CheckReachable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).CheckReachable(ctx, req.(*CheckReachableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Estimate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Estimate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/Estimate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Estimate(ctx, req.(*EstimateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Connector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "crpc.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAddress",
			Handler:    _Connector_CreateAddress_Handler,
		},
		{
			MethodName: "AccountAddress",
			Handler:    _Connector_AccountAddress_Handler,
		},
		{
			MethodName: "PendingBalance",
			Handler:    _Connector_PendingBalance_Handler,
		},
		{
			MethodName: "PendingTransactions",
			Handler:    _Connector_PendingTransactions_Handler,
		},
		{
			MethodName: "GenerateTransaction",
			Handler:    _Connector_GenerateTransaction_Handler,
		},
		{
			MethodName: "SendTransaction",
			Handler:    _Connector_SendTransaction_Handler,
		},
		{
			MethodName: "Info",
			Handler:    _Connector_Info_Handler,
		},
		{
			MethodName: "CreateInvoice",
			Handler:    _Connector_CreateInvoice_Handler,
		},
		{
			MethodName: "SendPayment",
			Handler:    _Connector_SendPayment_Handler,
		},
		{
			MethodName: "CheckReachable",
			Handler:    _Connector_CheckReachable_Handler,
		},
		{
			MethodName: "Estimate",
			Handler:    _Connector_Estimate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1120 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdb, 0x6e, 0x1b, 0x37,
	0x13, 0xb6, 0xb4, 0x3a, 0x8e, 0x2c, 0x5b, 0xa6, 0x0f, 0xd8, 0x5f, 0x4e, 0x7e, 0x38, 0x8b, 0xa2,
	0x71, 0x5d, 0xc4, 0x28, 0x5c, 0x14, 0x28, 0xdc, 0x00, 0x85, 0x24, 0xab, 0xb1, 0x11, 0x27, 0x35,
	0xd6, 0xba, 0x69, 0x2e, 0x2a, 0x50, 0x2b, 0xda, 0x22, 0xac, 0xe5, 0x6e, 0x97, 0x94, 0x23, 0xbd,
	0x49, 0x1f, 0xb4, 0xbd, 0x2f, 0x78, 0x92, 0x76, 0xd3, 0xb5, 0x5a, 0xa4, 0x77, 0xe4, 0x1c, 0x3e,
	0x92, 0xf3, 0xcd, 0x0c, 0x07, 0xea, 0x49, 0x1c, 0x9c, 0xc6, 0x49, 0x24, 0x22, 0x54, 0x0a, 0x92,
	0x38, 0xf0, 0x7e, 0x84, 0xed, 0x3e, 0x17, 0x34, 0xc4, 0x82, 0xf8, 0xe4, 0xb7, 0x19, 0xe1, 0x02,
	0xed, 0x41, 0xb9, 0xc3, 0x39, 0x11, 0x6e, 0xe1, 0xa8, 0x70, 0x5c, 0xf7, 0xcb, 0x58, 0x6e, 0xd0,
	0x01, 0x54, 0x3a, 0x61, 0x34, 0x63, 0xc2, 0x2d, 0x2a, 0x71, 0x05, 0xab, 0x9d, 0xf7, 0x25, 0x20,
	0x03, 0x40, 0x23, 0xe6, 0x13, 0x1e, 0x47, 0x8c, 0x13, 0xd4, 0x02, 0x67, 0xc6, 0xc7, 0x06, 0x41,
	0x2e, 0xbd, 0x9f, 0x60, 0xaf, 0x97, 0x10, 0x2c, 0x48, 0x67, 0x3c, 0x4e, 0x08, 0xe7, 0xf6, 0x34,
	0x17, 0xaa, 0x38, 0x08, 0x14, 0xb0, 0xb6, 0xb6, 0x5b, 0x79, 0x0f, 0x75, 0xb4, 0x39, 0x50, 0x6f,
	0xbc, 0x37, 0xb0, 0xdf, 0xd1, 0x06, 0xff, 0x1d, 0xe8, 0x86, 0xb0, 0x31, 0x65, 0xf7, 0x5d, 0x3c,
	0xc5, 0x2c, 0x20, 0x9f, 0x0b, 0x74, 0x0d, 0x6d, 0x03, 0x34, 0x48, 0x30, 0xe3, 0x38, 0x90, 0x91,
	0xf8, 0xec, 0x6b, 0x5d, 0xc1, 0xe1, 0x1b, 0xc2, 0x48, 0x82, 0x05, 0x49, 0xc1, 0x2d, 0x03, 0xbb,
	0x0f, 0x95, 0x04, 0x7f, 0x1c, 0x8a, 0xb9, 0x42, 0xdb, 0xf4, 0xcb, 0x09, 0xfe, 0x38, 0x98, 0xa3,
	0x5d, 0x28, 0x8b, 0xf9, 0x90, 0x8e, 0x0d, 0x56, 0x49, 0xcc, 0xaf, 0xc6, 0x5e, 0x1f, 0xfe, 0x77,
	0x3b, 0x1b, 0x05, 0x09, 0x1d, 0x91, 0x9f, 0xd9, 0x0d, 0x5e, 0x84, 0x84, 0x09, 0x9e, 0x62, 0x19,
	0xff, 0x9d, 0x65, 0x04, 0x25, 0xb1, 0x88, 0xc9, 0x12, 0x66, 0x11, 0x13, 0xef, 0xf7, 0x02, 0xb8,
	0xdd, 0x69, 0x14, 0x3c, 0x04, 0x13, 0x4c, 0x99, 0x79, 0xaa, 0x81, 0x43, 0x2f, 0xa1, 0x1a, 0xeb,
	0xa5, 0x02, 0x6a, 0x9c, 0x35, 0x4f, 0x65, 0x5e, 0x9d, 0x1a, 0xbd, 0x6f, 0xb5, 0xe8, 0x0b, 0x68,
	0x06, 0x11, 0xbb, 0xa3, 0x89, 0xce, 0x14, 0xae, 0x8e, 0x70, 0xfc, 0xac, 0x10, 0xbd, 0x02, 0x94,
	0x11, 0x0c, 0xa7, 0xe4, 0x4e, 0xb8, 0x8e, 0x32, 0xdd, 0xc9, 0x68, 0xae, 0xc9, 0x9d, 0xf0, 0x16,
	0x50, 0xb5, 0x17, 0xd9, 0x82, 0x22, 0xb5, 0x09, 0x57, 0xa4, 0x63, 0x99, 0xaf, 0x38, 0x27, 0x5f,
	0xd3, 0x7c, 0x38, 0x59, 0x3e, 0xa4, 0x46, 0xa7, 0x94, 0x5b, 0x32, 0x1a, 0xbd, 0x5d, 0x46, 0xa5,
	0x9c, 0x8a, 0xca, 0x36, 0x34, 0xfb, 0xa1, 0x88, 0x17, 0x96, 0x19, 0xef, 0x39, 0x54, 0x4d, 0x22,
	0x49, 0xfb, 0x31, 0x16, 0xd8, 0xdc, 0x46, 0xad, 0xa5, 0xba, 0xb3, 0x82, 0xcb, 0x53, 0x5f, 0xb1,
	0xc7, 0x88, 0x3e, 0xe1, 0x7d, 0x03, 0xfb, 0xbd, 0x09, 0x09, 0x1e, 0x7c, 0x82, 0x83, 0x09, 0x1e,
	0x4d, 0xc9, 0x7a, 0x1a, 0x5f, 0xc0, 0x26, 0x1d, 0x13, 0x26, 0xa8, 0x58, 0x0c, 0x1f, 0xc8, 0xc2,
	0x84, 0xa0, 0x61, 0x65, 0x6f, 0xc9, 0xc2, 0xfb, 0x05, 0x0e, 0x73, 0xb3, 0xd6, 0xe4, 0xd9, 0x39,
	0xd4, 0x0c, 0x73, 0xdc, 0x2d, 0x1c, 0x39, 0xc7, 0x8d, 0xb3, 0xff, 0x6b, 0x62, 0x9f, 0xca, 0x04,
	0x7f, 0x69, 0xef, 0xcd, 0xa0, 0x9d, 0x9b, 0xc2, 0xeb, 0x6e, 0xfc, 0x15, 0xb4, 0x12, 0x12, 0x10,
	0xfa, 0x48, 0x92, 0xa1, 0x65, 0x41, 0xdf, 0x7a, 0xdb, 0xca, 0x6d, 0xf8, 0x56, 0xcc, 0x3a, 0x99,
	0x4e, 0xd4, 0x87, 0x83, 0x5b, 0xc2, 0xc6, 0xff, 0xfa, 0xc8, 0x55, 0x29, 0x15, 0x53, 0xa5, 0xe4,
	0x35, 0xa1, 0x71, 0xc5, 0xee, 0x22, 0xe3, 0xeb, 0xfd, 0x59, 0x84, 0xe6, 0x35, 0xbd, 0x9f, 0x08,
	0x46, 0xd9, 0xbd, 0x54, 0x48, 0x7e, 0x26, 0x11, 0xb7, 0x60, 0x6a, 0x2d, 0x65, 0x71, 0x94, 0xd8,
	0x5c, 0x53, 0x6b, 0xf4, 0x1c, 0x20, 0xa4, 0x6c, 0x98, 0xb9, 0x6b, 0x3d, 0xa4, 0x4c, 0xb7, 0x51,
	0xa5, 0xc6, 0x73, 0xab, 0x2e, 0x19, 0x35, 0x9e, 0x1b, 0xf5, 0x4b, 0xd8, 0x5e, 0x52, 0x18, 0xcf,
	0x46, 0x92, 0x45, 0x9d, 0x7e, 0x5b, 0x56, 0x7c, 0xa3, 0xa4, 0xea, 0x71, 0x53, 0x8a, 0xb9, 0x5b,
	0x31, 0x8f, 0x93, 0x1b, 0xf4, 0x0d, 0xec, 0xb1, 0x59, 0x38, 0x8c, 0x35, 0x47, 0xc3, 0x60, 0x82,
	0x19, 0x23, 0x53, 0xee, 0x56, 0x8f, 0x0a, 0xc7, 0x4d, 0x1f, 0xb1, 0x59, 0x68, 0xe8, 0xeb, 0x19,
	0x0d, 0x3a, 0x85, 0x5d, 0xe9, 0x21, 0x23, 0xf7, 0x48, 0x56, 0x0e, 0x35, 0xe5, 0xb0, 0xc3, 0x66,
	0x61, 0x47, 0x69, 0x96, 0xf6, 0x87, 0x50, 0xd7, 0x27, 0x90, 0x84, 0xbb, 0x75, 0x65, 0x55, 0x53,
	0xb0, 0x24, 0xe1, 0x32, 0x01, 0x47, 0x32, 0x51, 0x86, 0x13, 0x22, 0x63, 0xe7, 0x82, 0xd2, 0x37,
	0x94, 0xec, 0x52, 0x89, 0xe4, 0xfb, 0x8d, 0x09, 0xe6, 0x13, 0xb7, 0xa1, 0xdf, 0xaf, 0x0d, 0x30,
	0x9f, 0x78, 0x0b, 0xd8, 0xd4, 0x34, 0x98, 0x84, 0x3c, 0x04, 0x87, 0x19, 0x06, 0xb7, 0xce, 0xea,
	0x3a, 0x17, 0xdf, 0x13, 0xe1, 0x4b, 0xa9, 0x2a, 0x50, 0x1a, 0xae, 0xda, 0x16, 0x0d, 0x09, 0xfa,
	0x1e, 0x9a, 0x53, 0x79, 0x90, 0x7c, 0x3e, 0x65, 0x77, 0x91, 0x62, 0xa0, 0x71, 0xb6, 0xab, 0x5d,
	0x33, 0x94, 0xfa, 0x9b, 0xd6, 0x52, 0xee, 0xbc, 0x5f, 0xed, 0x57, 0x65, 0x2a, 0x72, 0x7d, 0x1a,
	0xa5, 0x1a, 0x4a, 0x31, 0xdb, 0x50, 0x9e, 0x4a, 0xd4, 0x0b, 0x40, 0x32, 0x51, 0x6d, 0xe1, 0xfc,
	0x13, 0x3a, 0xd5, 0xb7, 0xb0, 0xe8, 0x66, 0xeb, 0x9d, 0xc3, 0xc1, 0xa7, 0x2d, 0xc1, 0x84, 0xea,
	0x08, 0x1a, 0x94, 0x2f, 0xc5, 0xca, 0xaf, 0xe6, 0xa7, 0x45, 0x27, 0xdf, 0x99, 0x2f, 0x1e, 0x55,
	0xc1, 0xe9, 0x0e, 0x7a, 0xad, 0x0d, 0xb5, 0xe8, 0x5d, 0xb6, 0x0a, 0x72, 0xd1, 0x1f, 0x5c, 0xb6,
	0x8a, 0x72, 0x71, 0x3d, 0xe8, 0xb5, 0x1c, 0x54, 0x83, 0xd2, 0x45, 0xe7, 0xf6, 0xb2, 0x55, 0x3a,
	0xe9, 0x43, 0xe5, 0x1d, 0x4e, 0x1e, 0x88, 0x40, 0x00, 0x95, 0xee, 0xa0, 0x27, 0x0d, 0x37, 0xcc,
	0xba, 0x3b, 0x90, 0xde, 0x7a, 0x2d, 0xfd, 0x8a, 0xa8, 0x01, 0xd5, 0xee, 0xa0, 0xa7, 0x5c, 0x1d,
	0xa9, 0xe8, 0x0f, 0x2e, 0xa5, 0xa2, 0x74, 0xf2, 0x35, 0x38, 0xef, 0x35, 0xc6, 0x2d, 0x0d, 0x19,
	0x11, 0xad, 0x0d, 0x69, 0x3b, 0x20, 0x5c, 0xc8, 0x4d, 0x41, 0x6e, 0xde, 0x61, 0xca, 0xe4, 0xa6,
	0x78, 0xf6, 0x47, 0x19, 0xea, 0xbd, 0x88, 0x31, 0x12, 0x88, 0x28, 0x41, 0xe7, 0xd0, 0xcc, 0x4c,
	0x11, 0xa8, 0xad, 0xe9, 0xcc, 0x1b, 0x2d, 0xda, 0xe6, 0x2b, 0xb2, 0xa6, 0xaf, 0x61, 0x2b, 0x3b,
	0x39, 0xa0, 0x43, 0x63, 0x90, 0x37, 0x4f, 0xe4, 0x78, 0x67, 0xc7, 0x05, 0xeb, 0x9d, 0x3b, 0x44,
	0x58, 0x6f, 0x6b, 0xfb, 0x01, 0x76, 0x73, 0xba, 0x2d, 0x3a, 0xca, 0x40, 0xe4, 0x8c, 0x0f, 0xed,
	0x17, 0x6b, 0x2c, 0x0c, 0xdd, 0x1f, 0x60, 0x37, 0xa7, 0xdd, 0x5a, 0xec, 0xa7, 0x3b, 0xb1, 0xc5,
	0x5e, 0x37, 0x6e, 0x5c, 0xc0, 0xf6, 0x27, 0x3d, 0x15, 0x3d, 0xd3, 0x5e, 0xf9, 0xad, 0xb6, 0x6d,
	0xca, 0x2b, 0xf3, 0x35, 0xa2, 0x57, 0x50, 0x52, 0x9d, 0x73, 0x47, 0x2b, 0x53, 0xed, 0xb5, 0x8d,
	0xd2, 0xa2, 0xe5, 0xdf, 0xd3, 0xcc, 0xd4, 0x5f, 0x96, 0xe4, 0x6c, 0x51, 0xda, 0x40, 0x5b, 0xd3,
	0xd7, 0xd0, 0x48, 0xd5, 0x16, 0x72, 0x57, 0x97, 0xcd, 0x96, 0x5b, 0xfe, 0x45, 0xdf, 0xc2, 0x56,
	0xb6, 0xa6, 0x2c, 0xc9, 0xb9, 0x9f, 0x6f, 0xfb, 0x59, 0xbe, 0xd2, 0x80, 0xfd, 0x00, 0x35, 0x3b,
	0x5a, 0xa3, 0x7d, 0x73, 0x5a, 0x76, 0xd4, 0x6e, 0xbb, 0x19, 0x71, 0x2a, 0xf0, 0xa3, 0x8a, 0x1a,
	0xd2, 0xbf, 0xfd, 0x2b, 0x00, 0x00, 0xff, 0xff, 0x11, 0xda, 0x2a, 0xfb, 0xb1, 0x0b, 0x00, 0x00,
}
