// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rpc.proto

/*
Package crpc is a generated protocol buffer package.

It is generated from these files:
	rpc.proto

It has these top-level messages:
	EstimateRequest
	EstimationResponse
	CreateAddressRequest
	AccountAddressRequest
	PendingBalanceRequest
	PendingTransactionsRequest
	GenerateTransactionResponse
	SubcribeOnPaymentsRequest
	BlockchainPendingPayment
	Payment
	EmtpyResponse
	Balance
	Address
	Invoice
	CheckReachableRequest
	PendingTransactionsResponse
	GenerateTransactionRequest
	SendTransactionRequest
	NetworkInfoRequest
	LightningInfo
	NetworkInfoResponse
	CreateInvoiceRequest
	SendPaymentRequest
	CheckReachableResponse
*/
package crpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Asset is the list of a trading assets which are available in the exchange
// platform.
type Asset int32

const (
	Asset_BTC  Asset = 0
	Asset_BCH  Asset = 1
	Asset_ETH  Asset = 2
	Asset_LTC  Asset = 3
	Asset_DASH Asset = 4
)

var Asset_name = map[int32]string{
	0: "BTC",
	1: "BCH",
	2: "ETH",
	3: "LTC",
	4: "DASH",
}
var Asset_value = map[string]int32{
	"BTC":  0,
	"BCH":  1,
	"ETH":  2,
	"LTC":  3,
	"DASH": 4,
}

func (x Asset) String() string {
	return proto.EnumName(Asset_name, int32(x))
}
func (Asset) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Market is the list of trading markets which are available on the
// exchange platform.
type Market int32

const (
	Market_BTCETH  Market = 0
	Market_BTCBTH  Market = 1
	Market_BTCLTC  Market = 2
	Market_BTCDASH Market = 3
	Market_ETHLTC  Market = 4
)

var Market_name = map[int32]string{
	0: "BTCETH",
	1: "BTCBTH",
	2: "BTCLTC",
	3: "BTCDASH",
	4: "ETHLTC",
}
var Market_value = map[string]int32{
	"BTCETH":  0,
	"BTCBTH":  1,
	"BTCLTC":  2,
	"BTCDASH": 3,
	"ETHLTC":  4,
}

func (x Market) String() string {
	return proto.EnumName(Market_name, int32(x))
}
func (Market) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type EstimateRequest struct {
	Asset  string `protobuf:"bytes,1,opt,name=Asset,json=asset" json:"Asset,omitempty"`
	Amount string `protobuf:"bytes,2,opt,name=Amount,json=amount" json:"Amount,omitempty"`
}

func (m *EstimateRequest) Reset()                    { *m = EstimateRequest{} }
func (m *EstimateRequest) String() string            { return proto.CompactTextString(m) }
func (*EstimateRequest) ProtoMessage()               {}
func (*EstimateRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *EstimateRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *EstimateRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type EstimationResponse struct {
	Usd string `protobuf:"bytes,1,opt,name=usd" json:"usd,omitempty"`
}

func (m *EstimationResponse) Reset()                    { *m = EstimationResponse{} }
func (m *EstimationResponse) String() string            { return proto.CompactTextString(m) }
func (*EstimationResponse) ProtoMessage()               {}
func (*EstimationResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *EstimationResponse) GetUsd() string {
	if m != nil {
		return m.Usd
	}
	return ""
}

type CreateAddressRequest struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Asset   string `protobuf:"bytes,2,opt,name=asset" json:"asset,omitempty"`
}

func (m *CreateAddressRequest) Reset()                    { *m = CreateAddressRequest{} }
func (m *CreateAddressRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateAddressRequest) ProtoMessage()               {}
func (*CreateAddressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CreateAddressRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *CreateAddressRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

type AccountAddressRequest struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Asset   string `protobuf:"bytes,2,opt,name=asset" json:"asset,omitempty"`
}

func (m *AccountAddressRequest) Reset()                    { *m = AccountAddressRequest{} }
func (m *AccountAddressRequest) String() string            { return proto.CompactTextString(m) }
func (*AccountAddressRequest) ProtoMessage()               {}
func (*AccountAddressRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *AccountAddressRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *AccountAddressRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

type PendingBalanceRequest struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Asset   string `protobuf:"bytes,2,opt,name=asset" json:"asset,omitempty"`
}

func (m *PendingBalanceRequest) Reset()                    { *m = PendingBalanceRequest{} }
func (m *PendingBalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*PendingBalanceRequest) ProtoMessage()               {}
func (*PendingBalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *PendingBalanceRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *PendingBalanceRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

type PendingTransactionsRequest struct {
	Account string `protobuf:"bytes,1,opt,name=account" json:"account,omitempty"`
	Asset   string `protobuf:"bytes,2,opt,name=asset" json:"asset,omitempty"`
}

func (m *PendingTransactionsRequest) Reset()                    { *m = PendingTransactionsRequest{} }
func (m *PendingTransactionsRequest) String() string            { return proto.CompactTextString(m) }
func (*PendingTransactionsRequest) ProtoMessage()               {}
func (*PendingTransactionsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *PendingTransactionsRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *PendingTransactionsRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

type GenerateTransactionResponse struct {
	RawTx []byte `protobuf:"bytes,1,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
	TxId  string `protobuf:"bytes,2,opt,name=tx_id,json=txId" json:"tx_id,omitempty"`
}

func (m *GenerateTransactionResponse) Reset()                    { *m = GenerateTransactionResponse{} }
func (m *GenerateTransactionResponse) String() string            { return proto.CompactTextString(m) }
func (*GenerateTransactionResponse) ProtoMessage()               {}
func (*GenerateTransactionResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *GenerateTransactionResponse) GetRawTx() []byte {
	if m != nil {
		return m.RawTx
	}
	return nil
}

func (m *GenerateTransactionResponse) GetTxId() string {
	if m != nil {
		return m.TxId
	}
	return ""
}

type SubcribeOnPaymentsRequest struct {
	// Asset is the acronim name of asset.
	Asset string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	// Type is a type of network which is used to deliver the payment.
	Type string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
}

func (m *SubcribeOnPaymentsRequest) Reset()                    { *m = SubcribeOnPaymentsRequest{} }
func (m *SubcribeOnPaymentsRequest) String() string            { return proto.CompactTextString(m) }
func (*SubcribeOnPaymentsRequest) ProtoMessage()               {}
func (*SubcribeOnPaymentsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *SubcribeOnPaymentsRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *SubcribeOnPaymentsRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

// BlockchainPendingPayment is the transaction with confirmations number lower
// than required by the payment system to be treated as confirmed.
type BlockchainPendingPayment struct {
	Payment *Payment `protobuf:"bytes,1,opt,name=payment" json:"payment,omitempty"`
	// Confirmations is the number of confirmations.
	Confirmations int64 `protobuf:"varint,2,opt,name=confirmations" json:"confirmations,omitempty"`
	// ConfirmationsLeft is the number of confirmations left in order to
	// interpret the transaction as confirmed.
	ConfirmationsLeft int64 `protobuf:"varint,3,opt,name=confirmations_left,json=confirmationsLeft" json:"confirmations_left,omitempty"`
}

func (m *BlockchainPendingPayment) Reset()                    { *m = BlockchainPendingPayment{} }
func (m *BlockchainPendingPayment) String() string            { return proto.CompactTextString(m) }
func (*BlockchainPendingPayment) ProtoMessage()               {}
func (*BlockchainPendingPayment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *BlockchainPendingPayment) GetPayment() *Payment {
	if m != nil {
		return m.Payment
	}
	return nil
}

func (m *BlockchainPendingPayment) GetConfirmations() int64 {
	if m != nil {
		return m.Confirmations
	}
	return 0
}

func (m *BlockchainPendingPayment) GetConfirmationsLeft() int64 {
	if m != nil {
		return m.ConfirmationsLeft
	}
	return 0
}

// Payment is the structure which describe the action of funds movement from
// one user to another.
type Payment struct {
	// ID is an number which identifies the transaction inside the payment
	// system.
	Id string `protobuf:"bytes,1,opt,name=id" json:"id,omitempty"`
	// Amount is an number of money which is translated from one User to
	// another in this transaction.
	Amount string `protobuf:"bytes,2,opt,name=amount" json:"amount,omitempty"`
	// Account is the receiver account.
	Account string `protobuf:"bytes,3,opt,name=account" json:"account,omitempty"`
	// Address is an address of receiver.
	Address string `protobuf:"bytes,4,opt,name=address" json:"address,omitempty"`
	// Type is a type of network which is used to deliver the payment.
	Type string `protobuf:"bytes,5,opt,name=type" json:"type,omitempty"`
}

func (m *Payment) Reset()                    { *m = Payment{} }
func (m *Payment) String() string            { return proto.CompactTextString(m) }
func (*Payment) ProtoMessage()               {}
func (*Payment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *Payment) GetId() string {
	if m != nil {
		return m.Id
	}
	return ""
}

func (m *Payment) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Payment) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *Payment) GetAddress() string {
	if m != nil {
		return m.Address
	}
	return ""
}

func (m *Payment) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type EmtpyResponse struct {
}

func (m *EmtpyResponse) Reset()                    { *m = EmtpyResponse{} }
func (m *EmtpyResponse) String() string            { return proto.CompactTextString(m) }
func (*EmtpyResponse) ProtoMessage()               {}
func (*EmtpyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

type Balance struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *Balance) Reset()                    { *m = Balance{} }
func (m *Balance) String() string            { return proto.CompactTextString(m) }
func (*Balance) ProtoMessage()               {}
func (*Balance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *Balance) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type Address struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *Address) Reset()                    { *m = Address{} }
func (m *Address) String() string            { return proto.CompactTextString(m) }
func (*Address) ProtoMessage()               {}
func (*Address) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *Address) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type Invoice struct {
	Data string `protobuf:"bytes,1,opt,name=data" json:"data,omitempty"`
}

func (m *Invoice) Reset()                    { *m = Invoice{} }
func (m *Invoice) String() string            { return proto.CompactTextString(m) }
func (*Invoice) ProtoMessage()               {}
func (*Invoice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *Invoice) GetData() string {
	if m != nil {
		return m.Data
	}
	return ""
}

type CheckReachableRequest struct {
	Asset       string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	IdentityKey string `protobuf:"bytes,2,opt,name=identity_key,json=identityKey" json:"identity_key,omitempty"`
}

func (m *CheckReachableRequest) Reset()                    { *m = CheckReachableRequest{} }
func (m *CheckReachableRequest) String() string            { return proto.CompactTextString(m) }
func (*CheckReachableRequest) ProtoMessage()               {}
func (*CheckReachableRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *CheckReachableRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *CheckReachableRequest) GetIdentityKey() string {
	if m != nil {
		return m.IdentityKey
	}
	return ""
}

type PendingTransactionsResponse struct {
	Payments []*BlockchainPendingPayment `protobuf:"bytes,1,rep,name=payments" json:"payments,omitempty"`
}

func (m *PendingTransactionsResponse) Reset()                    { *m = PendingTransactionsResponse{} }
func (m *PendingTransactionsResponse) String() string            { return proto.CompactTextString(m) }
func (*PendingTransactionsResponse) ProtoMessage()               {}
func (*PendingTransactionsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *PendingTransactionsResponse) GetPayments() []*BlockchainPendingPayment {
	if m != nil {
		return m.Payments
	}
	return nil
}

type GenerateTransactionRequest struct {
	Asset           string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	ReceiverAddress string `protobuf:"bytes,2,opt,name=receiver_address,json=receiverAddress" json:"receiver_address,omitempty"`
	Amount          string `protobuf:"bytes,3,opt,name=amount" json:"amount,omitempty"`
}

func (m *GenerateTransactionRequest) Reset()                    { *m = GenerateTransactionRequest{} }
func (m *GenerateTransactionRequest) String() string            { return proto.CompactTextString(m) }
func (*GenerateTransactionRequest) ProtoMessage()               {}
func (*GenerateTransactionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *GenerateTransactionRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *GenerateTransactionRequest) GetReceiverAddress() string {
	if m != nil {
		return m.ReceiverAddress
	}
	return ""
}

func (m *GenerateTransactionRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type SendTransactionRequest struct {
	Asset string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	RawTx []byte `protobuf:"bytes,2,opt,name=raw_tx,json=rawTx,proto3" json:"raw_tx,omitempty"`
}

func (m *SendTransactionRequest) Reset()                    { *m = SendTransactionRequest{} }
func (m *SendTransactionRequest) String() string            { return proto.CompactTextString(m) }
func (*SendTransactionRequest) ProtoMessage()               {}
func (*SendTransactionRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *SendTransactionRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *SendTransactionRequest) GetRawTx() []byte {
	if m != nil {
		return m.RawTx
	}
	return nil
}

type NetworkInfoRequest struct {
	// Asset is the acronim name of asset.
	Asset string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	// Type is a type of network which is used to deliver the payment.
	Type string `protobuf:"bytes,2,opt,name=type" json:"type,omitempty"`
}

func (m *NetworkInfoRequest) Reset()                    { *m = NetworkInfoRequest{} }
func (m *NetworkInfoRequest) String() string            { return proto.CompactTextString(m) }
func (*NetworkInfoRequest) ProtoMessage()               {}
func (*NetworkInfoRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *NetworkInfoRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *NetworkInfoRequest) GetType() string {
	if m != nil {
		return m.Type
	}
	return ""
}

type LightningInfo struct {
	Host      string `protobuf:"bytes,1,opt,name=host" json:"host,omitempty"`
	Port      string `protobuf:"bytes,2,opt,name=port" json:"port,omitempty"`
	MinAmount string `protobuf:"bytes,3,opt,name=min_amount,json=minAmount" json:"min_amount,omitempty"`
	MaxAmount string `protobuf:"bytes,4,opt,name=max_amount,json=maxAmount" json:"max_amount,omitempty"`
	// The identity pubkey of the current node.
	IdentityPubkey string `protobuf:"bytes,5,opt,name=identity_pubkey,json=identityPubkey" json:"identity_pubkey,omitempty"`
	// If applicable, the alias of the current node, e.g. "bob"
	Alias string `protobuf:"bytes,6,opt,name=alias" json:"alias,omitempty"`
	// Number of pending channels
	NumPendingChannels uint32 `protobuf:"varint,7,opt,name=num_pending_channels,json=numPendingChannels" json:"num_pending_channels,omitempty"`
	// Number of active channels
	NumActiveChannels uint32 `protobuf:"varint,8,opt,name=num_active_channels,json=numActiveChannels" json:"num_active_channels,omitempty"`
	// Number of peers
	NumPeers uint32 `protobuf:"varint,9,opt,name=num_peers,json=numPeers" json:"num_peers,omitempty"`
	// The node's current view of the height of the best block
	BlockHeight uint32 `protobuf:"varint,10,opt,name=block_height,json=blockHeight" json:"block_height,omitempty"`
	// The node's current view of the hash of the best block
	BlockHash string `protobuf:"bytes,11,opt,name=block_hash,json=blockHash" json:"block_hash,omitempty"`
	// Whether the wallet's view is synced to the main chain
	SyncedToChain bool `protobuf:"varint,12,opt,name=synced_to_chain,json=syncedToChain" json:"synced_to_chain,omitempty"`
	// Whether the current node is connected to testnet
	Testnet bool `protobuf:"varint,13,opt,name=testnet" json:"testnet,omitempty"`
	// A list of active chains the node is connected to
	Chains []string `protobuf:"bytes,14,rep,name=chains" json:"chains,omitempty"`
}

func (m *LightningInfo) Reset()                    { *m = LightningInfo{} }
func (m *LightningInfo) String() string            { return proto.CompactTextString(m) }
func (*LightningInfo) ProtoMessage()               {}
func (*LightningInfo) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{19} }

func (m *LightningInfo) GetHost() string {
	if m != nil {
		return m.Host
	}
	return ""
}

func (m *LightningInfo) GetPort() string {
	if m != nil {
		return m.Port
	}
	return ""
}

func (m *LightningInfo) GetMinAmount() string {
	if m != nil {
		return m.MinAmount
	}
	return ""
}

func (m *LightningInfo) GetMaxAmount() string {
	if m != nil {
		return m.MaxAmount
	}
	return ""
}

func (m *LightningInfo) GetIdentityPubkey() string {
	if m != nil {
		return m.IdentityPubkey
	}
	return ""
}

func (m *LightningInfo) GetAlias() string {
	if m != nil {
		return m.Alias
	}
	return ""
}

func (m *LightningInfo) GetNumPendingChannels() uint32 {
	if m != nil {
		return m.NumPendingChannels
	}
	return 0
}

func (m *LightningInfo) GetNumActiveChannels() uint32 {
	if m != nil {
		return m.NumActiveChannels
	}
	return 0
}

func (m *LightningInfo) GetNumPeers() uint32 {
	if m != nil {
		return m.NumPeers
	}
	return 0
}

func (m *LightningInfo) GetBlockHeight() uint32 {
	if m != nil {
		return m.BlockHeight
	}
	return 0
}

func (m *LightningInfo) GetBlockHash() string {
	if m != nil {
		return m.BlockHash
	}
	return ""
}

func (m *LightningInfo) GetSyncedToChain() bool {
	if m != nil {
		return m.SyncedToChain
	}
	return false
}

func (m *LightningInfo) GetTestnet() bool {
	if m != nil {
		return m.Testnet
	}
	return false
}

func (m *LightningInfo) GetChains() []string {
	if m != nil {
		return m.Chains
	}
	return nil
}

type NetworkInfoResponse struct {
	// Types that are valid to be assigned to Data:
	//	*NetworkInfoResponse_LightingInfo
	Data isNetworkInfoResponse_Data `protobuf_oneof:"Data"`
}

func (m *NetworkInfoResponse) Reset()                    { *m = NetworkInfoResponse{} }
func (m *NetworkInfoResponse) String() string            { return proto.CompactTextString(m) }
func (*NetworkInfoResponse) ProtoMessage()               {}
func (*NetworkInfoResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{20} }

type isNetworkInfoResponse_Data interface {
	isNetworkInfoResponse_Data()
}

type NetworkInfoResponse_LightingInfo struct {
	LightingInfo *LightningInfo `protobuf:"bytes,1,opt,name=lighting_info,json=lightingInfo,oneof"`
}

func (*NetworkInfoResponse_LightingInfo) isNetworkInfoResponse_Data() {}

func (m *NetworkInfoResponse) GetData() isNetworkInfoResponse_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *NetworkInfoResponse) GetLightingInfo() *LightningInfo {
	if x, ok := m.GetData().(*NetworkInfoResponse_LightingInfo); ok {
		return x.LightingInfo
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*NetworkInfoResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _NetworkInfoResponse_OneofMarshaler, _NetworkInfoResponse_OneofUnmarshaler, _NetworkInfoResponse_OneofSizer, []interface{}{
		(*NetworkInfoResponse_LightingInfo)(nil),
	}
}

func _NetworkInfoResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*NetworkInfoResponse)
	// Data
	switch x := m.Data.(type) {
	case *NetworkInfoResponse_LightingInfo:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.LightingInfo); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("NetworkInfoResponse.Data has unexpected type %T", x)
	}
	return nil
}

func _NetworkInfoResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*NetworkInfoResponse)
	switch tag {
	case 1: // Data.lighting_info
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(LightningInfo)
		err := b.DecodeMessage(msg)
		m.Data = &NetworkInfoResponse_LightingInfo{msg}
		return true, err
	default:
		return false, nil
	}
}

func _NetworkInfoResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*NetworkInfoResponse)
	// Data
	switch x := m.Data.(type) {
	case *NetworkInfoResponse_LightingInfo:
		s := proto.Size(x.LightingInfo)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type CreateInvoiceRequest struct {
	Asset   string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	Account string `protobuf:"bytes,2,opt,name=account" json:"account,omitempty"`
	Amount  string `protobuf:"bytes,3,opt,name=amount" json:"amount,omitempty"`
}

func (m *CreateInvoiceRequest) Reset()                    { *m = CreateInvoiceRequest{} }
func (m *CreateInvoiceRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateInvoiceRequest) ProtoMessage()               {}
func (*CreateInvoiceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{21} }

func (m *CreateInvoiceRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *CreateInvoiceRequest) GetAccount() string {
	if m != nil {
		return m.Account
	}
	return ""
}

func (m *CreateInvoiceRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type SendPaymentRequest struct {
	Asset   string `protobuf:"bytes,1,opt,name=asset" json:"asset,omitempty"`
	Invoice string `protobuf:"bytes,2,opt,name=invoice" json:"invoice,omitempty"`
}

func (m *SendPaymentRequest) Reset()                    { *m = SendPaymentRequest{} }
func (m *SendPaymentRequest) String() string            { return proto.CompactTextString(m) }
func (*SendPaymentRequest) ProtoMessage()               {}
func (*SendPaymentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{22} }

func (m *SendPaymentRequest) GetAsset() string {
	if m != nil {
		return m.Asset
	}
	return ""
}

func (m *SendPaymentRequest) GetInvoice() string {
	if m != nil {
		return m.Invoice
	}
	return ""
}

type CheckReachableResponse struct {
	IsReachable bool `protobuf:"varint,2,opt,name=isReachable" json:"isReachable,omitempty"`
}

func (m *CheckReachableResponse) Reset()                    { *m = CheckReachableResponse{} }
func (m *CheckReachableResponse) String() string            { return proto.CompactTextString(m) }
func (*CheckReachableResponse) ProtoMessage()               {}
func (*CheckReachableResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{23} }

func (m *CheckReachableResponse) GetIsReachable() bool {
	if m != nil {
		return m.IsReachable
	}
	return false
}

func init() {
	proto.RegisterType((*EstimateRequest)(nil), "crpc.EstimateRequest")
	proto.RegisterType((*EstimationResponse)(nil), "crpc.EstimationResponse")
	proto.RegisterType((*CreateAddressRequest)(nil), "crpc.CreateAddressRequest")
	proto.RegisterType((*AccountAddressRequest)(nil), "crpc.AccountAddressRequest")
	proto.RegisterType((*PendingBalanceRequest)(nil), "crpc.PendingBalanceRequest")
	proto.RegisterType((*PendingTransactionsRequest)(nil), "crpc.PendingTransactionsRequest")
	proto.RegisterType((*GenerateTransactionResponse)(nil), "crpc.GenerateTransactionResponse")
	proto.RegisterType((*SubcribeOnPaymentsRequest)(nil), "crpc.SubcribeOnPaymentsRequest")
	proto.RegisterType((*BlockchainPendingPayment)(nil), "crpc.BlockchainPendingPayment")
	proto.RegisterType((*Payment)(nil), "crpc.Payment")
	proto.RegisterType((*EmtpyResponse)(nil), "crpc.EmtpyResponse")
	proto.RegisterType((*Balance)(nil), "crpc.Balance")
	proto.RegisterType((*Address)(nil), "crpc.Address")
	proto.RegisterType((*Invoice)(nil), "crpc.Invoice")
	proto.RegisterType((*CheckReachableRequest)(nil), "crpc.CheckReachableRequest")
	proto.RegisterType((*PendingTransactionsResponse)(nil), "crpc.PendingTransactionsResponse")
	proto.RegisterType((*GenerateTransactionRequest)(nil), "crpc.GenerateTransactionRequest")
	proto.RegisterType((*SendTransactionRequest)(nil), "crpc.SendTransactionRequest")
	proto.RegisterType((*NetworkInfoRequest)(nil), "crpc.NetworkInfoRequest")
	proto.RegisterType((*LightningInfo)(nil), "crpc.LightningInfo")
	proto.RegisterType((*NetworkInfoResponse)(nil), "crpc.NetworkInfoResponse")
	proto.RegisterType((*CreateInvoiceRequest)(nil), "crpc.CreateInvoiceRequest")
	proto.RegisterType((*SendPaymentRequest)(nil), "crpc.SendPaymentRequest")
	proto.RegisterType((*CheckReachableResponse)(nil), "crpc.CheckReachableResponse")
	proto.RegisterEnum("crpc.Asset", Asset_name, Asset_value)
	proto.RegisterEnum("crpc.Market", Market_name, Market_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for Connector service

type ConnectorClient interface {
	//
	// CreateAddress is used to create deposit address in choosen blockchain
	// network.
	//
	// NOTE: Works only for blockchain daemons.
	CreateAddress(ctx context.Context, in *CreateAddressRequest, opts ...grpc.CallOption) (*Address, error)
	//
	// AccountAddress return the deposit address of account.
	//
	// NOTE: Works only for blockchain daemons.
	AccountAddress(ctx context.Context, in *AccountAddressRequest, opts ...grpc.CallOption) (*Address, error)
	//
	// PendingBalance return the amount of funds waiting to be confirmed.
	//
	// NOTE: Works only for blockchain daemons.
	PendingBalance(ctx context.Context, in *PendingBalanceRequest, opts ...grpc.CallOption) (*Balance, error)
	//
	// PendingTransactions return the transactions which has confirmation
	// number lower the required by payment system.
	//
	// NOTE: Works only for blockchain daemons.
	PendingTransactions(ctx context.Context, in *PendingTransactionsRequest, opts ...grpc.CallOption) (*PendingTransactionsResponse, error)
	//
	// GenerateTransaction generates raw blockchain transaction.
	//
	// NOTE: Blockchain endpoint.
	GenerateTransaction(ctx context.Context, in *GenerateTransactionRequest, opts ...grpc.CallOption) (*GenerateTransactionResponse, error)
	//
	// SendTransaction send the given transaction to the blockchain network.
	//
	// NOTE: Works only for blockchain daemons.
	SendTransaction(ctx context.Context, in *SendTransactionRequest, opts ...grpc.CallOption) (*EmtpyResponse, error)
	//
	// NetworkInfo returns information about the daemon and its network,
	// depending on the requested
	NetworkInfo(ctx context.Context, in *NetworkInfoRequest, opts ...grpc.CallOption) (*NetworkInfoResponse, error)
	//
	// CreateInvoice creates recept for sender lightning node which contains
	// the information about receiver node and
	//
	// NOTE: Works only for lightning network daemons.
	CreateInvoice(ctx context.Context, in *CreateInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error)
	//
	// SendPayment is used to send specific amount of money inside lightning
	// network.
	//
	// NOTE: Works only for lightning network daemons.
	SendPayment(ctx context.Context, in *SendPaymentRequest, opts ...grpc.CallOption) (*EmtpyResponse, error)
	//
	// CheckReachable checks that given node can be reached from our
	// lightning node.
	//
	// NOTE: Works only for lightning network daemons.
	CheckReachable(ctx context.Context, in *CheckReachableRequest, opts ...grpc.CallOption) (*CheckReachableResponse, error)
	//
	// Estimate estimates the dollar price of the choosen asset.
	Estimate(ctx context.Context, in *EstimateRequest, opts ...grpc.CallOption) (*EstimationResponse, error)
}

type connectorClient struct {
	cc *grpc.ClientConn
}

func NewConnectorClient(cc *grpc.ClientConn) ConnectorClient {
	return &connectorClient{cc}
}

func (c *connectorClient) CreateAddress(ctx context.Context, in *CreateAddressRequest, opts ...grpc.CallOption) (*Address, error) {
	out := new(Address)
	err := grpc.Invoke(ctx, "/crpc.Connector/CreateAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) AccountAddress(ctx context.Context, in *AccountAddressRequest, opts ...grpc.CallOption) (*Address, error) {
	out := new(Address)
	err := grpc.Invoke(ctx, "/crpc.Connector/AccountAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) PendingBalance(ctx context.Context, in *PendingBalanceRequest, opts ...grpc.CallOption) (*Balance, error) {
	out := new(Balance)
	err := grpc.Invoke(ctx, "/crpc.Connector/PendingBalance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) PendingTransactions(ctx context.Context, in *PendingTransactionsRequest, opts ...grpc.CallOption) (*PendingTransactionsResponse, error) {
	out := new(PendingTransactionsResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/PendingTransactions", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) GenerateTransaction(ctx context.Context, in *GenerateTransactionRequest, opts ...grpc.CallOption) (*GenerateTransactionResponse, error) {
	out := new(GenerateTransactionResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/GenerateTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) SendTransaction(ctx context.Context, in *SendTransactionRequest, opts ...grpc.CallOption) (*EmtpyResponse, error) {
	out := new(EmtpyResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/SendTransaction", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) NetworkInfo(ctx context.Context, in *NetworkInfoRequest, opts ...grpc.CallOption) (*NetworkInfoResponse, error) {
	out := new(NetworkInfoResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/NetworkInfo", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) CreateInvoice(ctx context.Context, in *CreateInvoiceRequest, opts ...grpc.CallOption) (*Invoice, error) {
	out := new(Invoice)
	err := grpc.Invoke(ctx, "/crpc.Connector/CreateInvoice", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) SendPayment(ctx context.Context, in *SendPaymentRequest, opts ...grpc.CallOption) (*EmtpyResponse, error) {
	out := new(EmtpyResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/SendPayment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) CheckReachable(ctx context.Context, in *CheckReachableRequest, opts ...grpc.CallOption) (*CheckReachableResponse, error) {
	out := new(CheckReachableResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/CheckReachable", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *connectorClient) Estimate(ctx context.Context, in *EstimateRequest, opts ...grpc.CallOption) (*EstimationResponse, error) {
	out := new(EstimationResponse)
	err := grpc.Invoke(ctx, "/crpc.Connector/Estimate", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for Connector service

type ConnectorServer interface {
	//
	// CreateAddress is used to create deposit address in choosen blockchain
	// network.
	//
	// NOTE: Works only for blockchain daemons.
	CreateAddress(context.Context, *CreateAddressRequest) (*Address, error)
	//
	// AccountAddress return the deposit address of account.
	//
	// NOTE: Works only for blockchain daemons.
	AccountAddress(context.Context, *AccountAddressRequest) (*Address, error)
	//
	// PendingBalance return the amount of funds waiting to be confirmed.
	//
	// NOTE: Works only for blockchain daemons.
	PendingBalance(context.Context, *PendingBalanceRequest) (*Balance, error)
	//
	// PendingTransactions return the transactions which has confirmation
	// number lower the required by payment system.
	//
	// NOTE: Works only for blockchain daemons.
	PendingTransactions(context.Context, *PendingTransactionsRequest) (*PendingTransactionsResponse, error)
	//
	// GenerateTransaction generates raw blockchain transaction.
	//
	// NOTE: Blockchain endpoint.
	GenerateTransaction(context.Context, *GenerateTransactionRequest) (*GenerateTransactionResponse, error)
	//
	// SendTransaction send the given transaction to the blockchain network.
	//
	// NOTE: Works only for blockchain daemons.
	SendTransaction(context.Context, *SendTransactionRequest) (*EmtpyResponse, error)
	//
	// NetworkInfo returns information about the daemon and its network,
	// depending on the requested
	NetworkInfo(context.Context, *NetworkInfoRequest) (*NetworkInfoResponse, error)
	//
	// CreateInvoice creates recept for sender lightning node which contains
	// the information about receiver node and
	//
	// NOTE: Works only for lightning network daemons.
	CreateInvoice(context.Context, *CreateInvoiceRequest) (*Invoice, error)
	//
	// SendPayment is used to send specific amount of money inside lightning
	// network.
	//
	// NOTE: Works only for lightning network daemons.
	SendPayment(context.Context, *SendPaymentRequest) (*EmtpyResponse, error)
	//
	// CheckReachable checks that given node can be reached from our
	// lightning node.
	//
	// NOTE: Works only for lightning network daemons.
	CheckReachable(context.Context, *CheckReachableRequest) (*CheckReachableResponse, error)
	//
	// Estimate estimates the dollar price of the choosen asset.
	Estimate(context.Context, *EstimateRequest) (*EstimationResponse, error)
}

func RegisterConnectorServer(s *grpc.Server, srv ConnectorServer) {
	s.RegisterService(&_Connector_serviceDesc, srv)
}

func _Connector_CreateAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).CreateAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/CreateAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).CreateAddress(ctx, req.(*CreateAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_AccountAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(AccountAddressRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).AccountAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/AccountAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).AccountAddress(ctx, req.(*AccountAddressRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_PendingBalance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PendingBalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).PendingBalance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/PendingBalance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).PendingBalance(ctx, req.(*PendingBalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_PendingTransactions_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PendingTransactionsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).PendingTransactions(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/PendingTransactions",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).PendingTransactions(ctx, req.(*PendingTransactionsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_GenerateTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(GenerateTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).GenerateTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/GenerateTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).GenerateTransaction(ctx, req.(*GenerateTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_SendTransaction_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendTransactionRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).SendTransaction(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/SendTransaction",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).SendTransaction(ctx, req.(*SendTransactionRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_NetworkInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NetworkInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).NetworkInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/NetworkInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).NetworkInfo(ctx, req.(*NetworkInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_CreateInvoice_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateInvoiceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).CreateInvoice(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/CreateInvoice",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).CreateInvoice(ctx, req.(*CreateInvoiceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_SendPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).SendPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/SendPayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).SendPayment(ctx, req.(*SendPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_CheckReachable_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CheckReachableRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).CheckReachable(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/CheckReachable",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).CheckReachable(ctx, req.(*CheckReachableRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _Connector_Estimate_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ConnectorServer).Estimate(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.Connector/Estimate",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ConnectorServer).Estimate(ctx, req.(*EstimateRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Connector_serviceDesc = grpc.ServiceDesc{
	ServiceName: "crpc.Connector",
	HandlerType: (*ConnectorServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateAddress",
			Handler:    _Connector_CreateAddress_Handler,
		},
		{
			MethodName: "AccountAddress",
			Handler:    _Connector_AccountAddress_Handler,
		},
		{
			MethodName: "PendingBalance",
			Handler:    _Connector_PendingBalance_Handler,
		},
		{
			MethodName: "PendingTransactions",
			Handler:    _Connector_PendingTransactions_Handler,
		},
		{
			MethodName: "GenerateTransaction",
			Handler:    _Connector_GenerateTransaction_Handler,
		},
		{
			MethodName: "SendTransaction",
			Handler:    _Connector_SendTransaction_Handler,
		},
		{
			MethodName: "NetworkInfo",
			Handler:    _Connector_NetworkInfo_Handler,
		},
		{
			MethodName: "CreateInvoice",
			Handler:    _Connector_CreateInvoice_Handler,
		},
		{
			MethodName: "SendPayment",
			Handler:    _Connector_SendPayment_Handler,
		},
		{
			MethodName: "CheckReachable",
			Handler:    _Connector_CheckReachable_Handler,
		},
		{
			MethodName: "Estimate",
			Handler:    _Connector_Estimate_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1130 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xa4, 0x56, 0xdd, 0x6e, 0x1a, 0x47,
	0x14, 0x0e, 0x2c, 0xe6, 0xe7, 0x60, 0x0c, 0x19, 0x62, 0x6b, 0x83, 0x93, 0x8a, 0xac, 0xaa, 0xc4,
	0x8d, 0x54, 0xab, 0x72, 0xd5, 0x9b, 0x34, 0x6a, 0x05, 0x98, 0x06, 0x2b, 0x6e, 0x6b, 0xad, 0xb9,
	0x49, 0x2e, 0xba, 0x1a, 0x76, 0xc7, 0x66, 0x64, 0x98, 0xdd, 0xee, 0x0c, 0x36, 0x3c, 0x42, 0xdf,
	0xa0, 0x6f, 0xd5, 0x57, 0xaa, 0xe6, 0x0f, 0xb3, 0xf1, 0xda, 0x6d, 0xd3, 0xbb, 0x39, 0x7f, 0xdf,
	0xcc, 0x9e, 0xf3, 0x9d, 0xb3, 0x07, 0x6a, 0x69, 0x12, 0x1e, 0x26, 0x69, 0x2c, 0x62, 0x54, 0x0a,
	0xd3, 0x24, 0xf4, 0x7e, 0x84, 0xe6, 0x90, 0x0b, 0x3a, 0xc7, 0x82, 0xf8, 0xe4, 0xf7, 0x05, 0xe1,
	0x02, 0x3d, 0x81, 0xad, 0x1e, 0xe7, 0x44, 0xb8, 0x85, 0x6e, 0xe1, 0xa0, 0xe6, 0x6f, 0x61, 0x29,
	0xa0, 0x3d, 0x28, 0xf7, 0xe6, 0xf1, 0x82, 0x09, 0xb7, 0xa8, 0xd4, 0x65, 0xac, 0x24, 0xef, 0x25,
	0x20, 0x03, 0x40, 0x63, 0xe6, 0x13, 0x9e, 0xc4, 0x8c, 0x13, 0xd4, 0x02, 0x67, 0xc1, 0x23, 0x83,
	0x20, 0x8f, 0xde, 0x4f, 0xf0, 0x64, 0x90, 0x12, 0x2c, 0x48, 0x2f, 0x8a, 0x52, 0xc2, 0xb9, 0xbd,
	0xcd, 0x85, 0x0a, 0x0e, 0x43, 0x05, 0xac, 0xbd, 0xad, 0x28, 0xdf, 0xa1, 0xae, 0x36, 0x17, 0x6a,
	0xc1, 0x7b, 0x07, 0xbb, 0x3d, 0xed, 0xf0, 0xff, 0x81, 0xce, 0x08, 0x8b, 0x28, 0xbb, 0xec, 0xe3,
	0x19, 0x66, 0x21, 0xf9, 0x5c, 0xa0, 0x53, 0xe8, 0x18, 0xa0, 0x71, 0x8a, 0x19, 0xc7, 0xa1, 0xcc,
	0xc4, 0x67, 0x3f, 0xeb, 0x04, 0xf6, 0xdf, 0x11, 0x46, 0x52, 0x2c, 0xc8, 0x06, 0xdc, 0x3a, 0xb1,
	0xbb, 0x50, 0x4e, 0xf1, 0x4d, 0x20, 0x96, 0x0a, 0x6d, 0xdb, 0xdf, 0x4a, 0xf1, 0xcd, 0x78, 0x89,
	0xda, 0xb0, 0x25, 0x96, 0x01, 0x8d, 0x0c, 0x56, 0x49, 0x2c, 0x4f, 0x22, 0x6f, 0x08, 0x4f, 0xcf,
	0x17, 0x93, 0x30, 0xa5, 0x13, 0xf2, 0x2b, 0x3b, 0xc3, 0xab, 0x39, 0x61, 0x82, 0x6f, 0x54, 0x19,
	0xdf, 0xad, 0x32, 0x82, 0x92, 0x58, 0x25, 0x64, 0x0d, 0xb3, 0x4a, 0x88, 0xf7, 0x67, 0x01, 0xdc,
	0xfe, 0x2c, 0x0e, 0xaf, 0xc2, 0x29, 0xa6, 0xcc, 0x7c, 0xaa, 0x81, 0x43, 0xaf, 0xa0, 0x92, 0xe8,
	0xa3, 0x02, 0xaa, 0x1f, 0x35, 0x0e, 0x25, 0xaf, 0x0e, 0x8d, 0xdd, 0xb7, 0x56, 0xf4, 0x25, 0x34,
	0xc2, 0x98, 0x5d, 0xd0, 0x54, 0x33, 0x85, 0xab, 0x2b, 0x1c, 0x3f, 0xab, 0x44, 0x5f, 0x03, 0xca,
	0x28, 0x82, 0x19, 0xb9, 0x10, 0xae, 0xa3, 0x5c, 0x1f, 0x67, 0x2c, 0xa7, 0xe4, 0x42, 0x78, 0x2b,
	0xa8, 0xd8, 0x87, 0xec, 0x40, 0x91, 0x5a, 0xc2, 0x15, 0x69, 0x24, 0xf9, 0x8a, 0x73, 0xf8, 0xba,
	0x59, 0x0f, 0x27, 0x5b, 0x0f, 0x69, 0xd1, 0x94, 0x72, 0x4b, 0xc6, 0xa2, 0xc5, 0x75, 0x56, 0xb6,
	0x36, 0xb2, 0xd2, 0x84, 0xc6, 0x70, 0x2e, 0x92, 0x95, 0xad, 0x8c, 0xf7, 0x1c, 0x2a, 0x86, 0x48,
	0xd2, 0x3f, 0xc2, 0x02, 0x9b, 0xd7, 0xa8, 0xb3, 0x34, 0xf7, 0x6e, 0xe1, 0xf2, 0xcc, 0x27, 0xec,
	0x3a, 0xa6, 0xf7, 0x44, 0x9f, 0xc1, 0xee, 0x60, 0x4a, 0xc2, 0x2b, 0x9f, 0xe0, 0x70, 0x8a, 0x27,
	0x33, 0xf2, 0x70, 0x19, 0x5f, 0xc0, 0x36, 0x8d, 0x08, 0x13, 0x54, 0xac, 0x82, 0x2b, 0xb2, 0x32,
	0x29, 0xa8, 0x5b, 0xdd, 0x7b, 0xb2, 0xf2, 0x3e, 0xc0, 0x7e, 0x2e, 0x6b, 0x0d, 0xcf, 0xde, 0x40,
	0xd5, 0x54, 0x8e, 0xbb, 0x85, 0xae, 0x73, 0x50, 0x3f, 0xfa, 0x42, 0x17, 0xf6, 0x3e, 0x26, 0xf8,
	0x6b, 0x7f, 0x6f, 0x01, 0x9d, 0x5c, 0x0a, 0x3f, 0xf4, 0xe2, 0xaf, 0xa0, 0x95, 0x92, 0x90, 0xd0,
	0x6b, 0x92, 0x06, 0xb6, 0x0a, 0xfa, 0xd5, 0x4d, 0xab, 0xb7, 0xe9, 0xbb, 0xad, 0xac, 0x93, 0x99,
	0x44, 0x43, 0xd8, 0x3b, 0x27, 0x2c, 0xfa, 0xd7, 0x57, 0xde, 0xb6, 0x52, 0x71, 0xa3, 0x95, 0xbc,
	0x1f, 0x00, 0xfd, 0x42, 0xc4, 0x4d, 0x9c, 0x5e, 0x9d, 0xb0, 0x8b, 0xf8, 0xbf, 0xb7, 0xcb, 0x5f,
	0x0e, 0x34, 0x4e, 0xe9, 0xe5, 0x54, 0x30, 0xca, 0x2e, 0x25, 0x84, 0xf4, 0x9a, 0xc6, 0xdc, 0x86,
	0xaa, 0xb3, 0xd4, 0x25, 0x71, 0x6a, 0xc9, 0xa9, 0xce, 0xe8, 0x39, 0xc0, 0x9c, 0xb2, 0x20, 0xf3,
	0x71, 0xb5, 0x39, 0x65, 0x7a, 0xee, 0x2a, 0x33, 0x5e, 0x5a, 0x73, 0xc9, 0x98, 0xf1, 0xd2, 0x98,
	0x5f, 0x41, 0x73, 0x5d, 0xf3, 0x64, 0x31, 0x91, 0x65, 0xd7, 0x7c, 0xdd, 0xb1, 0xea, 0x33, 0xa5,
	0x55, 0x9f, 0x32, 0xa3, 0x98, 0xbb, 0x65, 0xf3, 0x29, 0x52, 0x40, 0xdf, 0xc0, 0x13, 0xb6, 0x98,
	0x07, 0x89, 0x2e, 0x6a, 0x10, 0x4e, 0x31, 0x63, 0x64, 0xc6, 0xdd, 0x4a, 0xb7, 0x70, 0xd0, 0xf0,
	0x11, 0x5b, 0xcc, 0x4d, 0xbd, 0x07, 0xc6, 0x82, 0x0e, 0xa1, 0x2d, 0x23, 0x64, 0xaa, 0xaf, 0xc9,
	0x6d, 0x40, 0x55, 0x05, 0x3c, 0x66, 0x8b, 0x79, 0x4f, 0x59, 0xd6, 0xfe, 0xfb, 0x50, 0xd3, 0x37,
	0x90, 0x94, 0xbb, 0x35, 0xe5, 0x55, 0x55, 0xb0, 0x24, 0xe5, 0x92, 0xb1, 0x13, 0xc9, 0xac, 0x60,
	0x4a, 0x64, 0xee, 0x5c, 0x50, 0xf6, 0xba, 0xd2, 0x8d, 0x94, 0x4a, 0x7e, 0xbf, 0x71, 0xc1, 0x7c,
	0xea, 0xd6, 0xf5, 0xf7, 0x6b, 0x07, 0xcc, 0xa7, 0xe8, 0x25, 0x34, 0xf9, 0x8a, 0x85, 0x24, 0x0a,
	0x44, 0x1c, 0x28, 0x82, 0xba, 0xdb, 0xdd, 0xc2, 0x41, 0xd5, 0x6f, 0x68, 0xf5, 0x38, 0x1e, 0x48,
	0xa5, 0x6c, 0x73, 0x41, 0xb8, 0x60, 0x44, 0xb8, 0x0d, 0x65, 0xb7, 0xa2, 0x24, 0x96, 0x8a, 0xe3,
	0xee, 0x4e, 0xd7, 0x91, 0xc4, 0xd2, 0x92, 0xf7, 0x01, 0xda, 0x19, 0x46, 0xac, 0x5b, 0xa4, 0x31,
	0x93, 0x0f, 0x93, 0xe9, 0xa2, 0xec, 0x22, 0x36, 0x03, 0xb0, 0xad, 0xfb, 0x24, 0x43, 0x81, 0xd1,
	0x23, 0x7f, 0xdb, 0xfa, 0x4a, 0xb9, 0x5f, 0x86, 0xd2, 0xb1, 0xec, 0xeb, 0xdf, 0xec, 0x5f, 0xd1,
	0x34, 0xff, 0xc3, 0x74, 0xdb, 0x98, 0x5d, 0xc5, 0xec, 0xec, 0xba, 0xaf, 0x27, 0x8e, 0x01, 0xc9,
	0x9e, 0xb0, 0x3d, 0xfa, 0x4f, 0xe8, 0x54, 0xbf, 0xc2, 0xa2, 0x1b, 0xd1, 0x7b, 0x03, 0x7b, 0x9f,
	0x4e, 0x1f, 0x93, 0x83, 0x2e, 0xd4, 0x29, 0x5f, 0xab, 0x55, 0x5c, 0xd5, 0xdf, 0x54, 0xbd, 0xfe,
	0xce, 0x6c, 0x13, 0xa8, 0x02, 0x4e, 0x7f, 0x3c, 0x68, 0x3d, 0x52, 0x87, 0xc1, 0xa8, 0x55, 0x90,
	0x87, 0xe1, 0x78, 0xd4, 0x2a, 0xca, 0xc3, 0xe9, 0x78, 0xd0, 0x72, 0x50, 0x15, 0x4a, 0xc7, 0xbd,
	0xf3, 0x51, 0xab, 0xf4, 0x7a, 0x08, 0xe5, 0x9f, 0x71, 0x7a, 0x45, 0x04, 0x02, 0x28, 0xf7, 0xc7,
	0x03, 0xe9, 0xf8, 0xc8, 0x9c, 0xfb, 0x63, 0x19, 0xad, 0xcf, 0x32, 0xae, 0x88, 0xea, 0x50, 0xe9,
	0x8f, 0x07, 0x2a, 0xd4, 0x91, 0x86, 0xe1, 0x78, 0x24, 0x0d, 0xa5, 0xa3, 0x3f, 0xca, 0x50, 0x1b,
	0xc4, 0x8c, 0x91, 0x50, 0xc4, 0xa9, 0xac, 0x58, 0x66, 0x07, 0x41, 0x1d, 0x5d, 0xab, 0xbc, 0xc5,
	0xa4, 0x63, 0x7e, 0x64, 0xd6, 0xf5, 0x2d, 0xec, 0x64, 0xf7, 0x0e, 0xb4, 0x6f, 0x1c, 0xf2, 0xb6,
	0x91, 0x9c, 0xe8, 0xec, 0xb2, 0x61, 0xa3, 0x73, 0x57, 0x10, 0x1b, 0x6d, 0x7d, 0x3f, 0x42, 0x3b,
	0x67, 0x56, 0xa3, 0x6e, 0x06, 0x22, 0x67, 0xf9, 0xe8, 0xbc, 0x78, 0xc0, 0xc3, 0x54, 0xf0, 0x23,
	0xb4, 0x73, 0x86, 0xb5, 0xc5, 0xbe, 0x7f, 0x8e, 0x5b, 0xec, 0x87, 0x96, 0x95, 0x63, 0x68, 0x7e,
	0x32, 0x91, 0xd1, 0x33, 0x1d, 0x95, 0x3f, 0xa8, 0x3b, 0xa6, 0x77, 0x32, 0x3f, 0x56, 0xd4, 0x87,
	0xfa, 0x46, 0xfb, 0x21, 0x57, 0xfb, 0xdc, 0x9d, 0xd1, 0x9d, 0xa7, 0x39, 0x96, 0xdb, 0x5e, 0xcd,
	0xf4, 0x59, 0xb6, 0xf2, 0xd9, 0xe6, 0xb3, 0xd9, 0xb7, 0xae, 0x6f, 0xa1, 0xbe, 0xd1, 0x43, 0xf6,
	0xfe, 0xbb, 0x6d, 0x95, 0xff, 0xfa, 0xf7, 0xb0, 0x93, 0xed, 0x1d, 0x5b, 0xf9, 0xdc, 0xff, 0x79,
	0xe7, 0x59, 0xbe, 0xd1, 0x80, 0x7d, 0x0f, 0x55, 0xbb, 0xad, 0xa3, 0x5d, 0x73, 0x5b, 0x76, 0x7b,
	0xef, 0xb8, 0x19, 0xf5, 0x46, 0x35, 0x26, 0x65, 0xb5, 0xf7, 0x7f, 0xfb, 0x77, 0x00, 0x00, 0x00,
	0xff, 0xff, 0xd0, 0xcd, 0x31, 0x48, 0x04, 0x0c, 0x00, 0x00,
}
