// Code generated by protoc-gen-go. DO NOT EDIT.
// source: rpc.proto

/*
Package crpc is a generated protocol buffer package.

It is generated from these files:
	rpc.proto

It has these top-level messages:
	EmptyRequest
	EmptyResponse
	CreateReceiptRequest
	CreateReceiptResponse
	BalanceRequest
	Balance
	ValidateReceiptResponse
	Invoice
	BalanceResponse
	ValidateReceiptRequest
	EstimateFeeRequest
	EstimateFeeResponse
	SendPaymentRequest
	PaymentByIDRequest
	PaymentsByReceiptRequest
	PaymentsByReceiptResponse
	ListPaymentsRequest
	ListPaymentsResponse
	Payment
*/
package crpc

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// Asset is the list of a trading assets which are available in the exchange
// platform.
type Asset int32

const (
	Asset_ASSET_NONE Asset = 0
	//
	// Bitcoin
	Asset_BTC Asset = 1
	//
	// Bitcoin Cash
	Asset_BCH Asset = 2
	//
	// Ethereum
	Asset_ETH Asset = 3
	//
	// Litecoin
	Asset_LTC Asset = 4
	// Dash
	Asset_DASH Asset = 5
)

var Asset_name = map[int32]string{
	0: "ASSET_NONE",
	1: "BTC",
	2: "BCH",
	3: "ETH",
	4: "LTC",
	5: "DASH",
}
var Asset_value = map[string]int32{
	"ASSET_NONE": 0,
	"BTC":        1,
	"BCH":        2,
	"ETH":        3,
	"LTC":        4,
	"DASH":       5,
}

func (x Asset) String() string {
	return proto.EnumName(Asset_name, int32(x))
}
func (Asset) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

// Media is a list of possible media types. Media is a type of technology which
// is used to transport value of underlying asset.
type Media int32

const (
	Media_MEDIA_NONE Media = 0
	//
	// BLOCKCHAIN means that blockchain direct used for making the payments.
	Media_BLOCKCHAIN Media = 1
	//
	// LIGHTNING means that second layer on top of the blockchain is used for
	// making the payments.
	Media_LIGHTNING Media = 2
)

var Media_name = map[int32]string{
	0: "MEDIA_NONE",
	1: "BLOCKCHAIN",
	2: "LIGHTNING",
}
var Media_value = map[string]int32{
	"MEDIA_NONE": 0,
	"BLOCKCHAIN": 1,
	"LIGHTNING":  2,
}

func (x Media) String() string {
	return proto.EnumName(Media_name, int32(x))
}
func (Media) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// PaymentStatus denotes the stage of the processing the payment.
type PaymentStatus int32

const (
	PaymentStatus_STATUS_NONE PaymentStatus = 0
	//
	// WAITING means that payment has been created and waiting to be approved
	// for sending.
	PaymentStatus_WAITING PaymentStatus = 1
	//
	// PENDING means that service is seeing the payment, but it not yet approved
	// from the its POV.
	PaymentStatus_PENDING PaymentStatus = 2
	//
	// COMPLETED in case of outgoing/incoming payment this means that we
	// sent/received the transaction in/from the network and it was confirmed
	// number of times service believe sufficient. In case of the forward
	// transaction it means that we succesfully routed it through and
	// earned fee for that.
	PaymentStatus_COMPLETED PaymentStatus = 3
	//
	// FAILED means that services has tryied to send payment for couple of
	// times, but without success, and now service gave up.
	PaymentStatus_FAILED PaymentStatus = 4
)

var PaymentStatus_name = map[int32]string{
	0: "STATUS_NONE",
	1: "WAITING",
	2: "PENDING",
	3: "COMPLETED",
	4: "FAILED",
}
var PaymentStatus_value = map[string]int32{
	"STATUS_NONE": 0,
	"WAITING":     1,
	"PENDING":     2,
	"COMPLETED":   3,
	"FAILED":      4,
}

func (x PaymentStatus) String() string {
	return proto.EnumName(PaymentStatus_name, int32(x))
}
func (PaymentStatus) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

// PaymentDirection denotes the direction of the payment, whether payment is
// 	going form us to someone else, or form someone else to us.
type PaymentDirection int32

const (
	PaymentDirection_DIRECTION_NONE PaymentDirection = 0
	//
	// INCOMING type of payment which service has received from someone else
	// in the media.
	PaymentDirection_INCOMING PaymentDirection = 1
	//
	// OUTGOING type of payment which service has sent to someone else in the
	// media.
	PaymentDirection_OUTGOING PaymentDirection = 2
)

var PaymentDirection_name = map[int32]string{
	0: "DIRECTION_NONE",
	1: "INCOMING",
	2: "OUTGOING",
}
var PaymentDirection_value = map[string]int32{
	"DIRECTION_NONE": 0,
	"INCOMING":       1,
	"OUTGOING":       2,
}

func (x PaymentDirection) String() string {
	return proto.EnumName(PaymentDirection_name, int32(x))
}
func (PaymentDirection) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

// PaymentSystemSystem denotes is that payment belongs to business logic of
// payment server or it was originated by user / third-party service.
type PaymentSystem int32

const (
	PaymentSystem_SYSTEM_NONE PaymentSystem = 0
	//
	// INTERNAL type of payment usually services the purpose of payment
	// server itself for stabilisation of system. In lightning it might
	// channel rebalancing, in ethereum send on default address, in bitcoin
	// utxo reorganisation and "change" payment. This type of payment usually
	// is not shown outside.
	PaymentSystem_INTERNAL PaymentSystem = 1
	//
	// EXTERNAL type of payment which was originated by user / third-party
	// services, this is what usually interesting for external viewer. This
	// type of payment changes balance.
	PaymentSystem_EXTERNAL PaymentSystem = 2
)

var PaymentSystem_name = map[int32]string{
	0: "SYSTEM_NONE",
	1: "INTERNAL",
	2: "EXTERNAL",
}
var PaymentSystem_value = map[string]int32{
	"SYSTEM_NONE": 0,
	"INTERNAL":    1,
	"EXTERNAL":    2,
}

func (x PaymentSystem) String() string {
	return proto.EnumName(PaymentSystem_name, int32(x))
}
func (PaymentSystem) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

type EmptyRequest struct {
}

func (m *EmptyRequest) Reset()                    { *m = EmptyRequest{} }
func (m *EmptyRequest) String() string            { return proto.CompactTextString(m) }
func (*EmptyRequest) ProtoMessage()               {}
func (*EmptyRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type EmptyResponse struct {
}

func (m *EmptyResponse) Reset()                    { *m = EmptyResponse{} }
func (m *EmptyResponse) String() string            { return proto.CompactTextString(m) }
func (*EmptyResponse) ProtoMessage()               {}
func (*EmptyResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

type CreateReceiptRequest struct {
	//
	// Asset is an acronim of the crypto currency.
	Asset Asset `protobuf:"varint,1,opt,name=asset,enum=crpc.Asset" json:"asset,omitempty"`
	//
	// Media is a type of technology which is used to transport value of
	// underlying asset.
	Media Media `protobuf:"varint,2,opt,name=media,enum=crpc.Media" json:"media,omitempty"`
	//
	// (optional) Amount is the amount which should be received on this
	// receipt.
	Amount string `protobuf:"bytes,3,opt,name=amount" json:"amount,omitempty"`
	//
	// (optional) Description works only for lightning invoices. This
	// description will be placed in the invoice itself, which would allow user
	// to see what he paid for later in the wallet.
	Description string `protobuf:"bytes,4,opt,name=description" json:"description,omitempty"`
}

func (m *CreateReceiptRequest) Reset()                    { *m = CreateReceiptRequest{} }
func (m *CreateReceiptRequest) String() string            { return proto.CompactTextString(m) }
func (*CreateReceiptRequest) ProtoMessage()               {}
func (*CreateReceiptRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *CreateReceiptRequest) GetAsset() Asset {
	if m != nil {
		return m.Asset
	}
	return Asset_ASSET_NONE
}

func (m *CreateReceiptRequest) GetMedia() Media {
	if m != nil {
		return m.Media
	}
	return Media_MEDIA_NONE
}

func (m *CreateReceiptRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *CreateReceiptRequest) GetDescription() string {
	if m != nil {
		return m.Description
	}
	return ""
}

type CreateReceiptResponse struct {
	//
	// When this invoice was created.
	// NOTE: Only returns for lightning network media.
	CreationDate int64 `protobuf:"varint,1,opt,name=creation_date,json=creationDate" json:"creation_date,omitempty"`
	//
	// Receipt represent either blockchains address or lightning network invoice,
	// depending on the type of the request.
	Receipt string `protobuf:"bytes,2,opt,name=receipt" json:"receipt,omitempty"`
	//
	// Invoice expiry time in seconds. Default is 3600 (1 hour).
	// NOTE: Only returns for lightning network media.
	Expiry int64 `protobuf:"varint,3,opt,name=expiry" json:"expiry,omitempty"`
}

func (m *CreateReceiptResponse) Reset()                    { *m = CreateReceiptResponse{} }
func (m *CreateReceiptResponse) String() string            { return proto.CompactTextString(m) }
func (*CreateReceiptResponse) ProtoMessage()               {}
func (*CreateReceiptResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *CreateReceiptResponse) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

func (m *CreateReceiptResponse) GetReceipt() string {
	if m != nil {
		return m.Receipt
	}
	return ""
}

func (m *CreateReceiptResponse) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

type BalanceRequest struct {
	//
	// Asset is an acronim of the crypto currency.
	Asset Asset `protobuf:"varint,1,opt,name=asset,enum=crpc.Asset" json:"asset,omitempty"`
	//
	// Media is a type of technology which is used to transport value of
	// underlying asset.
	Media Media `protobuf:"varint,2,opt,name=media,enum=crpc.Media" json:"media,omitempty"`
}

func (m *BalanceRequest) Reset()                    { *m = BalanceRequest{} }
func (m *BalanceRequest) String() string            { return proto.CompactTextString(m) }
func (*BalanceRequest) ProtoMessage()               {}
func (*BalanceRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *BalanceRequest) GetAsset() Asset {
	if m != nil {
		return m.Asset
	}
	return Asset_ASSET_NONE
}

func (m *BalanceRequest) GetMedia() Media {
	if m != nil {
		return m.Media
	}
	return Media_MEDIA_NONE
}

type Balance struct {
	//
	// Available is the number of funds which could be used by this account
	// to send funds to someone else within the specified media.
	Available string `protobuf:"bytes,1,opt,name=available" json:"available,omitempty"`
	//
	// Pending is the number of funds are in the state of confirmation. In
	// case of blockchain media it is the transactions which are not
	// confirmed. In case of lightning media it is funds in pending payment
	// channels.
	Pending string `protobuf:"bytes,2,opt,name=pending" json:"pending,omitempty"`
	//
	// Asset is an acronim of the crypto currency.
	Asset Asset `protobuf:"varint,3,opt,name=asset,enum=crpc.Asset" json:"asset,omitempty"`
	//
	// Media is a type of technology which is used to transport value of
	// underlying asset.
	Media Media `protobuf:"varint,4,opt,name=media,enum=crpc.Media" json:"media,omitempty"`
}

func (m *Balance) Reset()                    { *m = Balance{} }
func (m *Balance) String() string            { return proto.CompactTextString(m) }
func (*Balance) ProtoMessage()               {}
func (*Balance) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *Balance) GetAvailable() string {
	if m != nil {
		return m.Available
	}
	return ""
}

func (m *Balance) GetPending() string {
	if m != nil {
		return m.Pending
	}
	return ""
}

func (m *Balance) GetAsset() Asset {
	if m != nil {
		return m.Asset
	}
	return Asset_ASSET_NONE
}

func (m *Balance) GetMedia() Media {
	if m != nil {
		return m.Media
	}
	return Media_MEDIA_NONE
}

type ValidateReceiptResponse struct {
	// Types that are valid to be assigned to Data:
	//	*ValidateReceiptResponse_Invoice
	Data isValidateReceiptResponse_Data `protobuf_oneof:"data"`
}

func (m *ValidateReceiptResponse) Reset()                    { *m = ValidateReceiptResponse{} }
func (m *ValidateReceiptResponse) String() string            { return proto.CompactTextString(m) }
func (*ValidateReceiptResponse) ProtoMessage()               {}
func (*ValidateReceiptResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

type isValidateReceiptResponse_Data interface{ isValidateReceiptResponse_Data() }

type ValidateReceiptResponse_Invoice struct {
	Invoice *Invoice `protobuf:"bytes,1,opt,name=invoice,oneof"`
}

func (*ValidateReceiptResponse_Invoice) isValidateReceiptResponse_Data() {}

func (m *ValidateReceiptResponse) GetData() isValidateReceiptResponse_Data {
	if m != nil {
		return m.Data
	}
	return nil
}

func (m *ValidateReceiptResponse) GetInvoice() *Invoice {
	if x, ok := m.GetData().(*ValidateReceiptResponse_Invoice); ok {
		return x.Invoice
	}
	return nil
}

// XXX_OneofFuncs is for the internal use of the proto package.
func (*ValidateReceiptResponse) XXX_OneofFuncs() (func(msg proto.Message, b *proto.Buffer) error, func(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error), func(msg proto.Message) (n int), []interface{}) {
	return _ValidateReceiptResponse_OneofMarshaler, _ValidateReceiptResponse_OneofUnmarshaler, _ValidateReceiptResponse_OneofSizer, []interface{}{
		(*ValidateReceiptResponse_Invoice)(nil),
	}
}

func _ValidateReceiptResponse_OneofMarshaler(msg proto.Message, b *proto.Buffer) error {
	m := msg.(*ValidateReceiptResponse)
	// data
	switch x := m.Data.(type) {
	case *ValidateReceiptResponse_Invoice:
		b.EncodeVarint(1<<3 | proto.WireBytes)
		if err := b.EncodeMessage(x.Invoice); err != nil {
			return err
		}
	case nil:
	default:
		return fmt.Errorf("ValidateReceiptResponse.Data has unexpected type %T", x)
	}
	return nil
}

func _ValidateReceiptResponse_OneofUnmarshaler(msg proto.Message, tag, wire int, b *proto.Buffer) (bool, error) {
	m := msg.(*ValidateReceiptResponse)
	switch tag {
	case 1: // data.invoice
		if wire != proto.WireBytes {
			return true, proto.ErrInternalBadWireType
		}
		msg := new(Invoice)
		err := b.DecodeMessage(msg)
		m.Data = &ValidateReceiptResponse_Invoice{msg}
		return true, err
	default:
		return false, nil
	}
}

func _ValidateReceiptResponse_OneofSizer(msg proto.Message) (n int) {
	m := msg.(*ValidateReceiptResponse)
	// data
	switch x := m.Data.(type) {
	case *ValidateReceiptResponse_Invoice:
		s := proto.Size(x.Invoice)
		n += proto.SizeVarint(1<<3 | proto.WireBytes)
		n += proto.SizeVarint(uint64(s))
		n += s
	case nil:
	default:
		panic(fmt.Sprintf("proto: unexpected type %T in oneof", x))
	}
	return n
}

type Invoice struct {
	//
	// An optional memo to attach along with the invoice. Used for record keeping
	// purposes for the invoice's creator, and will also be set in the
	// description field of the encoded payment request if the
	// description_hash field is not being used.
	Memo string `protobuf:"bytes,1,opt,name=memo" json:"memo,omitempty"`
	//
	// The value of this invoice in bitcoins.
	Value string `protobuf:"bytes,2,opt,name=value" json:"value,omitempty"`
	//
	// When this invoice was created.
	CreationDate int64 `protobuf:"varint,3,opt,name=creation_date,json=creationDate" json:"creation_date,omitempty"`
	//
	// Invoice expiry time in seconds. Default is 3600 (1 hour).
	Expiry int64 `protobuf:"varint,4,opt,name=expiry" json:"expiry,omitempty"`
	//
	// Fallback on-chain address in case of lightning network payment fail.
	FallbackAddr string `protobuf:"bytes,5,opt,name=fallback_addr,json=fallbackAddr" json:"fallback_addr,omitempty"`
	//
	// Lightning Network public key of receiving node.
	Destination string `protobuf:"bytes,6,opt,name=destination" json:"destination,omitempty"`
}

func (m *Invoice) Reset()                    { *m = Invoice{} }
func (m *Invoice) String() string            { return proto.CompactTextString(m) }
func (*Invoice) ProtoMessage()               {}
func (*Invoice) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *Invoice) GetMemo() string {
	if m != nil {
		return m.Memo
	}
	return ""
}

func (m *Invoice) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

func (m *Invoice) GetCreationDate() int64 {
	if m != nil {
		return m.CreationDate
	}
	return 0
}

func (m *Invoice) GetExpiry() int64 {
	if m != nil {
		return m.Expiry
	}
	return 0
}

func (m *Invoice) GetFallbackAddr() string {
	if m != nil {
		return m.FallbackAddr
	}
	return ""
}

func (m *Invoice) GetDestination() string {
	if m != nil {
		return m.Destination
	}
	return ""
}

type BalanceResponse struct {
	Balances []*Balance `protobuf:"bytes,1,rep,name=balances" json:"balances,omitempty"`
}

func (m *BalanceResponse) Reset()                    { *m = BalanceResponse{} }
func (m *BalanceResponse) String() string            { return proto.CompactTextString(m) }
func (*BalanceResponse) ProtoMessage()               {}
func (*BalanceResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{8} }

func (m *BalanceResponse) GetBalances() []*Balance {
	if m != nil {
		return m.Balances
	}
	return nil
}

type ValidateReceiptRequest struct {
	//
	// Receipt is the blockchain address in case of blockchain media and
	// lightning network invoice in case of lightning media.
	Receipt string `protobuf:"bytes,1,opt,name=receipt" json:"receipt,omitempty"`
	//
	// Asset is an acronim of the crypto currency.
	Asset Asset `protobuf:"varint,2,opt,name=asset,enum=crpc.Asset" json:"asset,omitempty"`
	//
	// Media is a type of technology which is used to transport value of
	// underlying asset.
	Media Media `protobuf:"varint,3,opt,name=media,enum=crpc.Media" json:"media,omitempty"`
	//
	// (optional) Amount is the amount which should be received on this
	// receipt.
	Amount string `protobuf:"bytes,4,opt,name=amount" json:"amount,omitempty"`
}

func (m *ValidateReceiptRequest) Reset()                    { *m = ValidateReceiptRequest{} }
func (m *ValidateReceiptRequest) String() string            { return proto.CompactTextString(m) }
func (*ValidateReceiptRequest) ProtoMessage()               {}
func (*ValidateReceiptRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{9} }

func (m *ValidateReceiptRequest) GetReceipt() string {
	if m != nil {
		return m.Receipt
	}
	return ""
}

func (m *ValidateReceiptRequest) GetAsset() Asset {
	if m != nil {
		return m.Asset
	}
	return Asset_ASSET_NONE
}

func (m *ValidateReceiptRequest) GetMedia() Media {
	if m != nil {
		return m.Media
	}
	return Media_MEDIA_NONE
}

func (m *ValidateReceiptRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

type EstimateFeeRequest struct {
	//
	// Asset is an acronim of the crypto currency.
	Asset Asset `protobuf:"varint,1,opt,name=asset,enum=crpc.Asset" json:"asset,omitempty"`
	//
	// Media is a type of technology which is used to transport value of
	// underlying asset.
	Media Media `protobuf:"varint,2,opt,name=media,enum=crpc.Media" json:"media,omitempty"`
	//
	// (optional) Amount is number of money which should be given to the
	// another entity.
	Amount string `protobuf:"bytes,3,opt,name=amount" json:"amount,omitempty"`
	//
	// (optional) Receipt represent either blockchains address or lightning
	// network invoice. If receipt is specified the number are more accurate
	// for lightning network payment.
	Receipt string `protobuf:"bytes,4,opt,name=receipt" json:"receipt,omitempty"`
}

func (m *EstimateFeeRequest) Reset()                    { *m = EstimateFeeRequest{} }
func (m *EstimateFeeRequest) String() string            { return proto.CompactTextString(m) }
func (*EstimateFeeRequest) ProtoMessage()               {}
func (*EstimateFeeRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{10} }

func (m *EstimateFeeRequest) GetAsset() Asset {
	if m != nil {
		return m.Asset
	}
	return Asset_ASSET_NONE
}

func (m *EstimateFeeRequest) GetMedia() Media {
	if m != nil {
		return m.Media
	}
	return Media_MEDIA_NONE
}

func (m *EstimateFeeRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *EstimateFeeRequest) GetReceipt() string {
	if m != nil {
		return m.Receipt
	}
	return ""
}

type EstimateFeeResponse struct {
	//
	// MediaFee is the fee which is taken by the blockchain or lightning
	// network in order to propagate the payment.
	MediaFee string `protobuf:"bytes,1,opt,name=media_fee,json=mediaFee" json:"media_fee,omitempty"`
}

func (m *EstimateFeeResponse) Reset()                    { *m = EstimateFeeResponse{} }
func (m *EstimateFeeResponse) String() string            { return proto.CompactTextString(m) }
func (*EstimateFeeResponse) ProtoMessage()               {}
func (*EstimateFeeResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{11} }

func (m *EstimateFeeResponse) GetMediaFee() string {
	if m != nil {
		return m.MediaFee
	}
	return ""
}

type SendPaymentRequest struct {
	//
	// Asset is an acronim of the crypto currency.
	Asset Asset `protobuf:"varint,1,opt,name=asset,enum=crpc.Asset" json:"asset,omitempty"`
	//
	// Media is a type of technology which is used to transport value of
	// underlying asset.
	Media Media `protobuf:"varint,2,opt,name=media,enum=crpc.Media" json:"media,omitempty"`
	//
	// Amount is number of money which should be given to the another entity.
	Amount string `protobuf:"bytes,3,opt,name=amount" json:"amount,omitempty"`
	//
	// Receipt represent either blockchains address or lightning
	// network invoice, which we should use determine payment receiver.
	Receipt string `protobuf:"bytes,4,opt,name=receipt" json:"receipt,omitempty"`
}

func (m *SendPaymentRequest) Reset()                    { *m = SendPaymentRequest{} }
func (m *SendPaymentRequest) String() string            { return proto.CompactTextString(m) }
func (*SendPaymentRequest) ProtoMessage()               {}
func (*SendPaymentRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{12} }

func (m *SendPaymentRequest) GetAsset() Asset {
	if m != nil {
		return m.Asset
	}
	return Asset_ASSET_NONE
}

func (m *SendPaymentRequest) GetMedia() Media {
	if m != nil {
		return m.Media
	}
	return Media_MEDIA_NONE
}

func (m *SendPaymentRequest) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *SendPaymentRequest) GetReceipt() string {
	if m != nil {
		return m.Receipt
	}
	return ""
}

type PaymentByIDRequest struct {
	//
	// PaymentID is the payment id which was created by service itself,
	// for unified identification of the payment.
	PaymentId string `protobuf:"bytes,1,opt,name=payment_id,json=paymentId" json:"payment_id,omitempty"`
}

func (m *PaymentByIDRequest) Reset()                    { *m = PaymentByIDRequest{} }
func (m *PaymentByIDRequest) String() string            { return proto.CompactTextString(m) }
func (*PaymentByIDRequest) ProtoMessage()               {}
func (*PaymentByIDRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{13} }

func (m *PaymentByIDRequest) GetPaymentId() string {
	if m != nil {
		return m.PaymentId
	}
	return ""
}

type PaymentsByReceiptRequest struct {
	//
	// Receipt represent either blockchains address or lightning
	// network invoice, depending on the type of the request.
	Receipt string `protobuf:"bytes,1,opt,name=receipt" json:"receipt,omitempty"`
}

func (m *PaymentsByReceiptRequest) Reset()                    { *m = PaymentsByReceiptRequest{} }
func (m *PaymentsByReceiptRequest) String() string            { return proto.CompactTextString(m) }
func (*PaymentsByReceiptRequest) ProtoMessage()               {}
func (*PaymentsByReceiptRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{14} }

func (m *PaymentsByReceiptRequest) GetReceipt() string {
	if m != nil {
		return m.Receipt
	}
	return ""
}

type PaymentsByReceiptResponse struct {
	Payments []*Payment `protobuf:"bytes,1,rep,name=payments" json:"payments,omitempty"`
}

func (m *PaymentsByReceiptResponse) Reset()                    { *m = PaymentsByReceiptResponse{} }
func (m *PaymentsByReceiptResponse) String() string            { return proto.CompactTextString(m) }
func (*PaymentsByReceiptResponse) ProtoMessage()               {}
func (*PaymentsByReceiptResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{15} }

func (m *PaymentsByReceiptResponse) GetPayments() []*Payment {
	if m != nil {
		return m.Payments
	}
	return nil
}

type ListPaymentsRequest struct {
	//
	// (optional) Status denotes the stage of the processing the payment.
	Status PaymentStatus `protobuf:"varint,1,opt,name=status,enum=crpc.PaymentStatus" json:"status,omitempty"`
	//
	// (optional) Direction denotes the direction of the payment.
	Direction PaymentDirection `protobuf:"varint,2,opt,name=direction,enum=crpc.PaymentDirection" json:"direction,omitempty"`
	//
	// (optional) Asset is an acronim of the crypto currency.
	Asset Asset `protobuf:"varint,3,opt,name=asset,enum=crpc.Asset" json:"asset,omitempty"`
	//
	// (optional) Media is a type of technology which is used to transport
	// value of underlying asset.
	Media Media `protobuf:"varint,4,opt,name=media,enum=crpc.Media" json:"media,omitempty"`
	//
	// (optional) PaymentSystem denotes is that payment belongs to business
	// logic of payment server or it was originated by user / third-party
	// service.
	System PaymentSystem `protobuf:"varint,5,opt,name=system,enum=crpc.PaymentSystem" json:"system,omitempty"`
}

func (m *ListPaymentsRequest) Reset()                    { *m = ListPaymentsRequest{} }
func (m *ListPaymentsRequest) String() string            { return proto.CompactTextString(m) }
func (*ListPaymentsRequest) ProtoMessage()               {}
func (*ListPaymentsRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{16} }

func (m *ListPaymentsRequest) GetStatus() PaymentStatus {
	if m != nil {
		return m.Status
	}
	return PaymentStatus_STATUS_NONE
}

func (m *ListPaymentsRequest) GetDirection() PaymentDirection {
	if m != nil {
		return m.Direction
	}
	return PaymentDirection_DIRECTION_NONE
}

func (m *ListPaymentsRequest) GetAsset() Asset {
	if m != nil {
		return m.Asset
	}
	return Asset_ASSET_NONE
}

func (m *ListPaymentsRequest) GetMedia() Media {
	if m != nil {
		return m.Media
	}
	return Media_MEDIA_NONE
}

func (m *ListPaymentsRequest) GetSystem() PaymentSystem {
	if m != nil {
		return m.System
	}
	return PaymentSystem_SYSTEM_NONE
}

type ListPaymentsResponse struct {
	Payments []*Payment `protobuf:"bytes,1,rep,name=payments" json:"payments,omitempty"`
}

func (m *ListPaymentsResponse) Reset()                    { *m = ListPaymentsResponse{} }
func (m *ListPaymentsResponse) String() string            { return proto.CompactTextString(m) }
func (*ListPaymentsResponse) ProtoMessage()               {}
func (*ListPaymentsResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{17} }

func (m *ListPaymentsResponse) GetPayments() []*Payment {
	if m != nil {
		return m.Payments
	}
	return nil
}

type Payment struct {
	//
	// PaymentID it is unique identificator of the payment generated inside
	// the system.
	PaymentId string `protobuf:"bytes,1,opt,name=payment_id,json=paymentId" json:"payment_id,omitempty"`
	//
	// UpdatedAt denotes the time when payment object has been last updated.
	UpdatedAt int64 `protobuf:"varint,2,opt,name=updated_at,json=updatedAt" json:"updated_at,omitempty"`
	//
	// Status denotes the stage of the processing the payment.
	Status PaymentStatus `protobuf:"varint,3,opt,name=status,enum=crpc.PaymentStatus" json:"status,omitempty"`
	//
	// Direction denotes the direction of the payment, whether
	// payment is going form us to someone else, or form someone else to us.
	Direction PaymentDirection `protobuf:"varint,4,opt,name=direction,enum=crpc.PaymentDirection" json:"direction,omitempty"`
	//
	// System denotes is that payment belongs to business logic of
	// payment server or it was originated by user / third-party service.
	System PaymentSystem `protobuf:"varint,11,opt,name=system,enum=crpc.PaymentSystem" json:"system,omitempty"`
	//
	// Asset is an acronim of the crypto currency.
	Asset Asset `protobuf:"varint,5,opt,name=asset,enum=crpc.Asset" json:"asset,omitempty"`
	//
	// Receipt is a string which identifies the receiver of the
	// payment. It is address in case of the blockchain media,
	// and lightning network invoice in case lightning media.
	Receipt string `protobuf:"bytes,6,opt,name=receipt" json:"receipt,omitempty"`
	// MediaID is identificator of the payment inside the media.
	// In case of blockchain media payment id is the transaction id,
	// in case of lightning media it is the payment hash. It is not used as
	// payment identificator because of the reason that it is not unique.
	MediaId string `protobuf:"bytes,7,opt,name=media_id,json=mediaId" json:"media_id,omitempty"`
	//
	// Media is a type of technology which is used to transport value of
	// underlying asset.
	Media Media `protobuf:"varint,8,opt,name=media,enum=crpc.Media" json:"media,omitempty"`
	//
	// Amount is the number of funds which receiver gets at the end.
	Amount string `protobuf:"bytes,9,opt,name=amount" json:"amount,omitempty"`
	//
	// MediaFee is the fee which is taken by the blockchain or lightning
	// network in order to propagate the payment.
	MediaFee string `protobuf:"bytes,10,opt,name=media_fee,json=mediaFee" json:"media_fee,omitempty"`
}

func (m *Payment) Reset()                    { *m = Payment{} }
func (m *Payment) String() string            { return proto.CompactTextString(m) }
func (*Payment) ProtoMessage()               {}
func (*Payment) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{18} }

func (m *Payment) GetPaymentId() string {
	if m != nil {
		return m.PaymentId
	}
	return ""
}

func (m *Payment) GetUpdatedAt() int64 {
	if m != nil {
		return m.UpdatedAt
	}
	return 0
}

func (m *Payment) GetStatus() PaymentStatus {
	if m != nil {
		return m.Status
	}
	return PaymentStatus_STATUS_NONE
}

func (m *Payment) GetDirection() PaymentDirection {
	if m != nil {
		return m.Direction
	}
	return PaymentDirection_DIRECTION_NONE
}

func (m *Payment) GetSystem() PaymentSystem {
	if m != nil {
		return m.System
	}
	return PaymentSystem_SYSTEM_NONE
}

func (m *Payment) GetAsset() Asset {
	if m != nil {
		return m.Asset
	}
	return Asset_ASSET_NONE
}

func (m *Payment) GetReceipt() string {
	if m != nil {
		return m.Receipt
	}
	return ""
}

func (m *Payment) GetMediaId() string {
	if m != nil {
		return m.MediaId
	}
	return ""
}

func (m *Payment) GetMedia() Media {
	if m != nil {
		return m.Media
	}
	return Media_MEDIA_NONE
}

func (m *Payment) GetAmount() string {
	if m != nil {
		return m.Amount
	}
	return ""
}

func (m *Payment) GetMediaFee() string {
	if m != nil {
		return m.MediaFee
	}
	return ""
}

func init() {
	proto.RegisterType((*EmptyRequest)(nil), "crpc.EmptyRequest")
	proto.RegisterType((*EmptyResponse)(nil), "crpc.EmptyResponse")
	proto.RegisterType((*CreateReceiptRequest)(nil), "crpc.CreateReceiptRequest")
	proto.RegisterType((*CreateReceiptResponse)(nil), "crpc.CreateReceiptResponse")
	proto.RegisterType((*BalanceRequest)(nil), "crpc.BalanceRequest")
	proto.RegisterType((*Balance)(nil), "crpc.Balance")
	proto.RegisterType((*ValidateReceiptResponse)(nil), "crpc.ValidateReceiptResponse")
	proto.RegisterType((*Invoice)(nil), "crpc.Invoice")
	proto.RegisterType((*BalanceResponse)(nil), "crpc.BalanceResponse")
	proto.RegisterType((*ValidateReceiptRequest)(nil), "crpc.ValidateReceiptRequest")
	proto.RegisterType((*EstimateFeeRequest)(nil), "crpc.EstimateFeeRequest")
	proto.RegisterType((*EstimateFeeResponse)(nil), "crpc.EstimateFeeResponse")
	proto.RegisterType((*SendPaymentRequest)(nil), "crpc.SendPaymentRequest")
	proto.RegisterType((*PaymentByIDRequest)(nil), "crpc.PaymentByIDRequest")
	proto.RegisterType((*PaymentsByReceiptRequest)(nil), "crpc.PaymentsByReceiptRequest")
	proto.RegisterType((*PaymentsByReceiptResponse)(nil), "crpc.PaymentsByReceiptResponse")
	proto.RegisterType((*ListPaymentsRequest)(nil), "crpc.ListPaymentsRequest")
	proto.RegisterType((*ListPaymentsResponse)(nil), "crpc.ListPaymentsResponse")
	proto.RegisterType((*Payment)(nil), "crpc.Payment")
	proto.RegisterEnum("crpc.Asset", Asset_name, Asset_value)
	proto.RegisterEnum("crpc.Media", Media_name, Media_value)
	proto.RegisterEnum("crpc.PaymentStatus", PaymentStatus_name, PaymentStatus_value)
	proto.RegisterEnum("crpc.PaymentDirection", PaymentDirection_name, PaymentDirection_value)
	proto.RegisterEnum("crpc.PaymentSystem", PaymentSystem_name, PaymentSystem_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for PayServer service

type PayServerClient interface {
	//
	// CreateReceipt is used to create blockchain deposit address in
	// case of blockchain media, and lightning network invoice in
	// case of the lightning media, which will be used to receive money from
	// external entity.
	CreateReceipt(ctx context.Context, in *CreateReceiptRequest, opts ...grpc.CallOption) (*CreateReceiptResponse, error)
	//
	// ValidateReceipt is used to validate receipt for given asset and media.
	ValidateReceipt(ctx context.Context, in *ValidateReceiptRequest, opts ...grpc.CallOption) (*ValidateReceiptResponse, error)
	//
	// Balance is used to determine balance.
	Balance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error)
	//
	// EstimateFee estimates the fee of the payment.
	EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error)
	//
	// SendPayment sends payment to the given recipient,
	// ensures in the validity of the receipt as well as the
	// account has enough money for doing that.
	SendPayment(ctx context.Context, in *SendPaymentRequest, opts ...grpc.CallOption) (*Payment, error)
	//
	// PaymentByID is used to fetch the information about payment, by the
	// given system payment id.
	PaymentByID(ctx context.Context, in *PaymentByIDRequest, opts ...grpc.CallOption) (*Payment, error)
	//
	// PaymentsByReceipt is used to fetch the information about payment, by the
	// given receipt.
	PaymentsByReceipt(ctx context.Context, in *PaymentsByReceiptRequest, opts ...grpc.CallOption) (*PaymentsByReceiptResponse, error)
	//
	// ListPayments returnes list of payment which were registered by the
	// system.
	ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error)
}

type payServerClient struct {
	cc *grpc.ClientConn
}

func NewPayServerClient(cc *grpc.ClientConn) PayServerClient {
	return &payServerClient{cc}
}

func (c *payServerClient) CreateReceipt(ctx context.Context, in *CreateReceiptRequest, opts ...grpc.CallOption) (*CreateReceiptResponse, error) {
	out := new(CreateReceiptResponse)
	err := grpc.Invoke(ctx, "/crpc.PayServer/CreateReceipt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *payServerClient) ValidateReceipt(ctx context.Context, in *ValidateReceiptRequest, opts ...grpc.CallOption) (*ValidateReceiptResponse, error) {
	out := new(ValidateReceiptResponse)
	err := grpc.Invoke(ctx, "/crpc.PayServer/ValidateReceipt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *payServerClient) Balance(ctx context.Context, in *BalanceRequest, opts ...grpc.CallOption) (*BalanceResponse, error) {
	out := new(BalanceResponse)
	err := grpc.Invoke(ctx, "/crpc.PayServer/Balance", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *payServerClient) EstimateFee(ctx context.Context, in *EstimateFeeRequest, opts ...grpc.CallOption) (*EstimateFeeResponse, error) {
	out := new(EstimateFeeResponse)
	err := grpc.Invoke(ctx, "/crpc.PayServer/EstimateFee", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *payServerClient) SendPayment(ctx context.Context, in *SendPaymentRequest, opts ...grpc.CallOption) (*Payment, error) {
	out := new(Payment)
	err := grpc.Invoke(ctx, "/crpc.PayServer/SendPayment", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *payServerClient) PaymentByID(ctx context.Context, in *PaymentByIDRequest, opts ...grpc.CallOption) (*Payment, error) {
	out := new(Payment)
	err := grpc.Invoke(ctx, "/crpc.PayServer/PaymentByID", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *payServerClient) PaymentsByReceipt(ctx context.Context, in *PaymentsByReceiptRequest, opts ...grpc.CallOption) (*PaymentsByReceiptResponse, error) {
	out := new(PaymentsByReceiptResponse)
	err := grpc.Invoke(ctx, "/crpc.PayServer/PaymentsByReceipt", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *payServerClient) ListPayments(ctx context.Context, in *ListPaymentsRequest, opts ...grpc.CallOption) (*ListPaymentsResponse, error) {
	out := new(ListPaymentsResponse)
	err := grpc.Invoke(ctx, "/crpc.PayServer/ListPayments", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for PayServer service

type PayServerServer interface {
	//
	// CreateReceipt is used to create blockchain deposit address in
	// case of blockchain media, and lightning network invoice in
	// case of the lightning media, which will be used to receive money from
	// external entity.
	CreateReceipt(context.Context, *CreateReceiptRequest) (*CreateReceiptResponse, error)
	//
	// ValidateReceipt is used to validate receipt for given asset and media.
	ValidateReceipt(context.Context, *ValidateReceiptRequest) (*ValidateReceiptResponse, error)
	//
	// Balance is used to determine balance.
	Balance(context.Context, *BalanceRequest) (*BalanceResponse, error)
	//
	// EstimateFee estimates the fee of the payment.
	EstimateFee(context.Context, *EstimateFeeRequest) (*EstimateFeeResponse, error)
	//
	// SendPayment sends payment to the given recipient,
	// ensures in the validity of the receipt as well as the
	// account has enough money for doing that.
	SendPayment(context.Context, *SendPaymentRequest) (*Payment, error)
	//
	// PaymentByID is used to fetch the information about payment, by the
	// given system payment id.
	PaymentByID(context.Context, *PaymentByIDRequest) (*Payment, error)
	//
	// PaymentsByReceipt is used to fetch the information about payment, by the
	// given receipt.
	PaymentsByReceipt(context.Context, *PaymentsByReceiptRequest) (*PaymentsByReceiptResponse, error)
	//
	// ListPayments returnes list of payment which were registered by the
	// system.
	ListPayments(context.Context, *ListPaymentsRequest) (*ListPaymentsResponse, error)
}

func RegisterPayServerServer(s *grpc.Server, srv PayServerServer) {
	s.RegisterService(&_PayServer_serviceDesc, srv)
}

func _PayServer_CreateReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CreateReceiptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PayServerServer).CreateReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.PayServer/CreateReceipt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PayServerServer).CreateReceipt(ctx, req.(*CreateReceiptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PayServer_ValidateReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ValidateReceiptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PayServerServer).ValidateReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.PayServer/ValidateReceipt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PayServerServer).ValidateReceipt(ctx, req.(*ValidateReceiptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PayServer_Balance_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(BalanceRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PayServerServer).Balance(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.PayServer/Balance",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PayServerServer).Balance(ctx, req.(*BalanceRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PayServer_EstimateFee_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EstimateFeeRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PayServerServer).EstimateFee(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.PayServer/EstimateFee",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PayServerServer).EstimateFee(ctx, req.(*EstimateFeeRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PayServer_SendPayment_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SendPaymentRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PayServerServer).SendPayment(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.PayServer/SendPayment",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PayServerServer).SendPayment(ctx, req.(*SendPaymentRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PayServer_PaymentByID_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentByIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PayServerServer).PaymentByID(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.PayServer/PaymentByID",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PayServerServer).PaymentByID(ctx, req.(*PaymentByIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PayServer_PaymentsByReceipt_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(PaymentsByReceiptRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PayServerServer).PaymentsByReceipt(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.PayServer/PaymentsByReceipt",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PayServerServer).PaymentsByReceipt(ctx, req.(*PaymentsByReceiptRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _PayServer_ListPayments_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(ListPaymentsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(PayServerServer).ListPayments(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/crpc.PayServer/ListPayments",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(PayServerServer).ListPayments(ctx, req.(*ListPaymentsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _PayServer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "crpc.PayServer",
	HandlerType: (*PayServerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "CreateReceipt",
			Handler:    _PayServer_CreateReceipt_Handler,
		},
		{
			MethodName: "ValidateReceipt",
			Handler:    _PayServer_ValidateReceipt_Handler,
		},
		{
			MethodName: "Balance",
			Handler:    _PayServer_Balance_Handler,
		},
		{
			MethodName: "EstimateFee",
			Handler:    _PayServer_EstimateFee_Handler,
		},
		{
			MethodName: "SendPayment",
			Handler:    _PayServer_SendPayment_Handler,
		},
		{
			MethodName: "PaymentByID",
			Handler:    _PayServer_PaymentByID_Handler,
		},
		{
			MethodName: "PaymentsByReceipt",
			Handler:    _PayServer_PaymentsByReceipt_Handler,
		},
		{
			MethodName: "ListPayments",
			Handler:    _PayServer_ListPayments_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "rpc.proto",
}

func init() { proto.RegisterFile("rpc.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 1048 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xc4, 0x57, 0xcd, 0x72, 0x9b, 0x56,
	0x14, 0x0e, 0x02, 0xfd, 0x70, 0xf4, 0x63, 0x7a, 0xed, 0xb8, 0x58, 0x49, 0x5a, 0x97, 0x6e, 0x52,
	0x77, 0xc6, 0x0b, 0x27, 0x93, 0x55, 0x36, 0x48, 0xc2, 0x16, 0x53, 0x09, 0x79, 0x10, 0x4e, 0xdb,
	0x95, 0xe6, 0x1a, 0x6e, 0x3a, 0x4c, 0x25, 0x44, 0x01, 0x79, 0xaa, 0x27, 0xc8, 0xa6, 0x8b, 0xae,
	0xfa, 0x18, 0xdd, 0xf6, 0xa1, 0xfa, 0x12, 0x1d, 0xee, 0xbd, 0x08, 0x90, 0xe4, 0xb1, 0x33, 0x93,
	0x69, 0x76, 0x9c, 0xf3, 0x9d, 0x73, 0xf4, 0x9d, 0x3f, 0x0e, 0x02, 0x39, 0x0a, 0xdd, 0xf3, 0x30,
	0x5a, 0x26, 0x4b, 0x24, 0xb9, 0x51, 0xe8, 0x6a, 0x1d, 0x68, 0x19, 0x8b, 0x30, 0x59, 0xdb, 0xe4,
	0xb7, 0x15, 0x89, 0x13, 0xed, 0x00, 0xda, 0x5c, 0x8e, 0xc3, 0x65, 0x10, 0x13, 0xed, 0x2f, 0x01,
	0x8e, 0xfa, 0x11, 0xc1, 0x09, 0xb1, 0x89, 0x4b, 0xfc, 0x30, 0xe1, 0x96, 0xe8, 0x1b, 0xa8, 0xe2,
	0x38, 0x26, 0x89, 0x2a, 0x9c, 0x0a, 0x2f, 0x3b, 0x17, 0xcd, 0xf3, 0x34, 0xde, 0xb9, 0x9e, 0xaa,
	0x6c, 0x86, 0xa4, 0x26, 0x0b, 0xe2, 0xf9, 0x58, 0xad, 0x14, 0x4d, 0xc6, 0xa9, 0xca, 0x66, 0x08,
	0x3a, 0x86, 0x1a, 0x5e, 0x2c, 0x57, 0x41, 0xa2, 0x8a, 0xa7, 0xc2, 0x4b, 0xd9, 0xe6, 0x12, 0x3a,
	0x85, 0xa6, 0x47, 0x62, 0x37, 0xf2, 0xc3, 0xc4, 0x5f, 0x06, 0xaa, 0x44, 0xc1, 0xa2, 0x4a, 0x0b,
	0xe0, 0xe9, 0x16, 0x2f, 0xc6, 0x18, 0x7d, 0x0b, 0x6d, 0x37, 0x05, 0xfc, 0x65, 0x30, 0xf3, 0x70,
	0x42, 0x28, 0x41, 0xd1, 0x6e, 0x65, 0xca, 0x01, 0x4e, 0x08, 0x52, 0xa1, 0x1e, 0x31, 0x3f, 0x4a,
	0x4e, 0xb6, 0x33, 0x31, 0x65, 0x44, 0x7e, 0x0f, 0xfd, 0x68, 0x4d, 0x19, 0x89, 0x36, 0x97, 0xb4,
	0x77, 0xd0, 0xe9, 0xe1, 0x39, 0x0e, 0x5c, 0xf2, 0x49, 0x2b, 0xa0, 0x7d, 0x10, 0xa0, 0xce, 0x03,
	0xa3, 0xe7, 0x20, 0xe3, 0x3b, 0xec, 0xcf, 0xf1, 0xed, 0x9c, 0xd1, 0x96, 0xed, 0x5c, 0x91, 0x72,
	0x0e, 0x49, 0xe0, 0xf9, 0xc1, 0x2f, 0x19, 0x67, 0x2e, 0xe6, 0x4c, 0xc4, 0x87, 0x99, 0x48, 0xf7,
	0x32, 0x19, 0xc1, 0x97, 0xef, 0xf0, 0xdc, 0xf7, 0xf6, 0xd4, 0xf4, 0x3b, 0xa8, 0xfb, 0xc1, 0xdd,
	0xd2, 0x77, 0x19, 0xad, 0xe6, 0x45, 0x9b, 0xf9, 0x9b, 0x4c, 0x39, 0x7c, 0x62, 0x67, 0x78, 0xaf,
	0x06, 0x92, 0x87, 0x13, 0xac, 0xfd, 0x23, 0x40, 0x9d, 0xc3, 0x08, 0x81, 0xb4, 0x20, 0x8b, 0x25,
	0x4f, 0x89, 0x3e, 0xa3, 0x23, 0xa8, 0xde, 0xe1, 0xf9, 0x8a, 0xf0, 0x5c, 0x98, 0xb0, 0xdb, 0x3c,
	0x71, 0x4f, 0xf3, 0xf2, 0x16, 0x49, 0xc5, 0x16, 0xa5, 0xce, 0xef, 0xf1, 0x7c, 0x7e, 0x8b, 0xdd,
	0x5f, 0x67, 0xd8, 0xf3, 0x22, 0xb5, 0x4a, 0x43, 0xb7, 0x32, 0xa5, 0xee, 0x79, 0x11, 0x9f, 0xac,
	0xc4, 0x0f, 0x68, 0x3c, 0xb5, 0xb6, 0x99, 0xac, 0x4c, 0xa5, 0xbd, 0x85, 0x83, 0x4d, 0xa7, 0x37,
	0xf9, 0x37, 0x6e, 0x99, 0x2a, 0x56, 0x85, 0x53, 0x31, 0x2f, 0x40, 0x66, 0xb8, 0x81, 0xb5, 0x3f,
	0x05, 0x38, 0xde, 0x29, 0x23, 0x1b, 0x98, 0xc2, 0xd0, 0x09, 0xe5, 0xa1, 0xdb, 0x34, 0xb0, 0xf2,
	0x70, 0x03, 0xc5, 0x47, 0x2c, 0x93, 0x54, 0x5c, 0x26, 0xed, 0x0f, 0x01, 0x90, 0x11, 0x27, 0xfe,
	0x02, 0x27, 0xe4, 0x92, 0x90, 0xff, 0x67, 0x83, 0x0b, 0xc9, 0x4a, 0xa5, 0x64, 0xb5, 0x0b, 0x38,
	0x2c, 0xb1, 0xe1, 0x35, 0x7e, 0x06, 0x32, 0x8d, 0x38, 0x7b, 0x4f, 0xb2, 0xe1, 0x6f, 0x50, 0xc5,
	0x25, 0x21, 0x34, 0x85, 0x29, 0x09, 0xbc, 0x6b, 0xbc, 0x5e, 0x90, 0x20, 0xf9, 0xdc, 0x29, 0xbc,
	0x02, 0xc4, 0x99, 0xf4, 0xd6, 0xe6, 0x20, 0x63, 0xf3, 0x02, 0x20, 0x64, 0xda, 0x99, 0xef, 0x65,
	0xfb, 0xcb, 0x35, 0xa6, 0xa7, 0xbd, 0x06, 0x95, 0x3b, 0xc5, 0xbd, 0xf5, 0x63, 0x47, 0x43, 0xbb,
	0x84, 0x93, 0x3d, 0x5e, 0xf9, 0x5c, 0xf2, 0xf8, 0x5b, 0x73, 0x99, 0xd5, 0x69, 0x03, 0x6b, 0xff,
	0x0a, 0x70, 0x38, 0xf2, 0xe3, 0x24, 0x0b, 0x96, 0xfd, 0xf2, 0xf7, 0x50, 0x8b, 0x13, 0x9c, 0xac,
	0x62, 0x5e, 0xc3, 0xc3, 0x52, 0x80, 0x29, 0x85, 0x6c, 0x6e, 0x82, 0x5e, 0x83, 0xec, 0xf9, 0x11,
	0x71, 0xe9, 0xea, 0xb0, 0x82, 0x1e, 0x97, 0xec, 0x07, 0x19, 0x6a, 0xe7, 0x86, 0x9f, 0xe6, 0xf5,
	0x44, 0x89, 0xae, 0xe3, 0x84, 0x2c, 0xe8, 0x5a, 0xef, 0x10, 0xa5, 0x90, 0xcd, 0x4d, 0x34, 0x1d,
	0x8e, 0xca, 0xc9, 0x7e, 0x7c, 0xc1, 0x3e, 0x88, 0x50, 0xe7, 0xda, 0x07, 0x3a, 0x9b, 0xc2, 0xab,
	0x30, 0x5d, 0x78, 0x6f, 0x86, 0xd9, 0x0e, 0x8b, 0xb6, 0xcc, 0x35, 0x7a, 0xb1, 0xc4, 0xe2, 0x47,
	0x96, 0x58, 0x7a, 0x6c, 0x89, 0xf3, 0xe2, 0x34, 0x1f, 0x2c, 0x4e, 0xde, 0x8f, 0xea, 0xbd, 0xfd,
	0x28, 0xcc, 0x63, 0xad, 0xfc, 0xaa, 0x3a, 0x01, 0xb6, 0x95, 0x69, 0x21, 0xea, 0x0c, 0xa2, 0xb2,
	0xe9, 0xe5, 0x4d, 0x6c, 0x3c, 0x62, 0xd5, 0xe4, 0xd2, 0xaa, 0x95, 0x96, 0x1f, 0xca, 0xcb, 0x7f,
	0x66, 0x40, 0x95, 0x92, 0x43, 0x1d, 0x00, 0x7d, 0x3a, 0x35, 0x9c, 0x99, 0x35, 0xb1, 0x0c, 0xe5,
	0x09, 0xaa, 0x83, 0xd8, 0x73, 0xfa, 0x8a, 0x40, 0x1f, 0xfa, 0x43, 0xa5, 0x92, 0x3e, 0x18, 0xce,
	0x50, 0x11, 0xd3, 0x87, 0x91, 0xd3, 0x57, 0x24, 0xd4, 0x00, 0x69, 0xa0, 0x4f, 0x87, 0x4a, 0xf5,
	0xec, 0x0d, 0x54, 0x29, 0x97, 0x34, 0xcc, 0xd8, 0x18, 0x98, 0x7a, 0x16, 0xa6, 0x03, 0xd0, 0x1b,
	0x4d, 0xfa, 0x3f, 0xf4, 0x87, 0xba, 0x69, 0x29, 0x02, 0x6a, 0x83, 0x3c, 0x32, 0xaf, 0x86, 0x8e,
	0x65, 0x5a, 0x57, 0x4a, 0xe5, 0xec, 0x06, 0xda, 0xa5, 0x56, 0xa1, 0x03, 0x68, 0x4e, 0x1d, 0xdd,
	0xb9, 0x99, 0x66, 0x01, 0x9a, 0x50, 0xff, 0x51, 0x37, 0x9d, 0xd4, 0x5c, 0x48, 0x85, 0x6b, 0xc3,
	0x1a, 0x50, 0xdf, 0x34, 0x54, 0x7f, 0x32, 0xbe, 0x1e, 0x19, 0x8e, 0x31, 0x50, 0x44, 0x04, 0x50,
	0xbb, 0xd4, 0xcd, 0x91, 0x31, 0x50, 0xa4, 0xb3, 0x1e, 0x28, 0xdb, 0x1d, 0x45, 0x08, 0x3a, 0x03,
	0xd3, 0x36, 0xfa, 0x8e, 0x39, 0xb1, 0xb2, 0xe0, 0x2d, 0x68, 0x98, 0x56, 0x7f, 0x32, 0x66, 0xd1,
	0x5b, 0xd0, 0x98, 0xdc, 0x38, 0x57, 0x13, 0x46, 0xed, 0x6d, 0x4e, 0x8d, 0xb5, 0x36, 0xa5, 0xf6,
	0xf3, 0xd4, 0x31, 0xc6, 0x25, 0x6f, 0xc7, 0xb0, 0x2d, 0x7d, 0xc4, 0xbc, 0x8d, 0x9f, 0xb8, 0x54,
	0xb9, 0xf8, 0x5b, 0x02, 0xf9, 0x1a, 0xaf, 0xa7, 0x24, 0xba, 0x23, 0x11, 0x1a, 0x42, 0xbb, 0xf4,
	0x41, 0x85, 0xba, 0xac, 0x7f, 0xfb, 0xbe, 0xfe, 0xba, 0xcf, 0xf6, 0x62, 0x7c, 0xc9, 0x2c, 0x38,
	0xd8, 0xba, 0x80, 0xe8, 0x39, 0xb3, 0xdf, 0x7f, 0x18, 0xbb, 0x2f, 0xee, 0x41, 0x79, 0xbc, 0x37,
	0xf9, 0x17, 0xd2, 0x51, 0xf9, 0xec, 0x72, 0xff, 0xa7, 0x5b, 0x5a, 0xee, 0xd7, 0x83, 0x66, 0xe1,
	0xd0, 0x20, 0x95, 0x59, 0xed, 0x5e, 0xc2, 0xee, 0xc9, 0x1e, 0x64, 0xf3, 0xdb, 0xcd, 0xc2, 0xdd,
	0xc9, 0x62, 0xec, 0x9e, 0xa2, 0x6e, 0xf9, 0x3d, 0x92, 0xfa, 0x15, 0x2e, 0x44, 0xe6, 0xb7, 0x7b,
	0x34, 0xb6, 0xfd, 0x1c, 0xf8, 0x62, 0xe7, 0x75, 0x8f, 0xbe, 0x2a, 0xd9, 0xec, 0x5c, 0x8f, 0xee,
	0xd7, 0xf7, 0xe2, 0x3c, 0x0b, 0x03, 0x5a, 0xc5, 0xd7, 0x21, 0xe2, 0x09, 0xef, 0xb9, 0x07, 0xdd,
	0xee, 0x3e, 0x88, 0x85, 0xb9, 0xad, 0xd1, 0xbf, 0x0e, 0xaf, 0xfe, 0x0b, 0x00, 0x00, 0xff, 0xff,
	0xeb, 0x68, 0xcc, 0x2b, 0x47, 0x0c, 0x00, 0x00,
}
